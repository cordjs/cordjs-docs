*********************
Главный класс виджета
*********************

Главный класс виджета является единственным обязательным артифактом виджета. Он должен располагаться в файле, который
называется так же, как и папка виджета, но с заглавной буквы. Сам класс тоже должен называться как файл и
наследоваться от класса ``/cord/core/Widget`` или класса другого виджета.

Главный класс виджета является экслюзивным владельцем его состояния, отвечает за рендеринг шаблона и публичное API
виджета. Он участвует как в серверном рендеринге, так и на стороне клиента (браузере).

Типичный класс виджета выглядит вот так:

.. code-block:: coffee
  :linenos:
  :caption: public/bundles/hello/example/widgets/currentTime/CurrentTime.coffee

  define [
    'cord!Widget'
  ], (Widget) ->

    class CurrentTime extends Widget

      @inject: ['api']

      css: true
      cssClass: 'b-current-time'
      rootTag: 'span'

      @initialCtx:
        time: '00:00:00'
        city: 'Moscow'

      @params:
        city: ':ctx'


      onShow: ->
        @updateTime()


      # Публичный метод
      updateTime: ->
        @ctx.set('time', @api.get('/local-time-for-city', city: @ctx.city))


Внедрение зависимостей (Dependency Injection)
=============================================

Для внедрения других сервисов как зависимостей в виджет (так же как и для других классов в CordJS) используется
статическое свойство ``@inject``. В CordJS применяется injection через свойства объекта, а не через конструктор.
Свойство ``@inject`` может быть задано в одном из трёх форматов:

* **Массив строк** --- список названий сервисов, которые нужно внедрить. Сервисы будут присвоены одноимённым свойствам
  экземпляра виджета.
* **Объект**, ключи которого используются как названия свойств (алиасы) в виджете, а значения --- названия сервисов,
  которые нужно внедрить под этими алиасами.
* **Функция**, которая (синхронно) возвращает один из двух предыдущих форматов.


Переменные контекста
====================

Для хренения своего внутреннего состояния (View-Model) виджет использует специальный объект класса ``Context`` в
переменной ``@ctx``. Структура данных внутреннего состояния ничем не ограничена, однако у виджета предусмотрено
специальное статическое свойство ``@initialCtx`` для установки значений по-умолчанию для переменных контекста и
рекомендуется перечислять в нём **все** возможные переменные. Таким образом разработчик может документировать
структуру внутреннего состояния виджета, и другим программистам будет проще понять логику его работы.

Свойство ``@initialCtx`` может быть либо объектом, ключи которого являются названями переменных контекста, а значения
--- значениями по-умолчанию, либо функцией, которая (синхронно) возвращает такой объект. Функция выполняется в
контексте **класса** виджета, поэтому в ней не доступны свойства и методы экземпляра виджета, такие как внедрённые
сервисы. Пример:

.. code-block:: coffee
  :linenos:

  @initialCtx: ->
    time = new Date

    time: time.getHours() + ':' + time.getMinutes() + ':' + time.getSeconds()
    city: 'Moscow'

.. warning::

  В качестве значений по умолчанию можно задавать любые скалярные выражения, а также массивы или объекты первого
  порядка (т.е. которые не содержат в себе других массивов или объектов).

  Это обусловлено тем, что без дополнительной обработки разные экземпляры виджета одного класса ссылались бы на один
  и тот же массив или объект по-умолчанию, что может приводить к неожиданным последствиям. CordJS делает
  поверхностный клон массивов и объектов при создании экземпляра виджета, поэтому массивы и объекты первого порядка
  допустимы.

  В большинстве случаев в качестве значения по умолчанию используют пустой массив или объект, чтобы
  обозначить тип переменной.

В переменные контекста не следует записывать фукнции или какие-либо сложные типизированные объекты (за исключением
поддерживаемых в CordJS моделей и коллекций), поскольку при серверном рендеринге контекст сериализуется, передаётся
по сети в браузер и восстанавливается. CordJS не умеет передавать таким образом функции и сложные объекты.

.. note::

  Есть зарезервированные названия, которые нельзя использовать в качестве переменных контекста (из-за особенностей
  работы Dust.js): ``css``, ``deferred``, ``i18n``, ``placeholder``, ``url``, ``widget`` и ``widgetInitializer``.

Подробнее API работы с контекстом описано в соответствующем разделе.


Обработка входящих параметров
=============================

Входящие параметры --- основной способ определения поведения виджета извне, своего рода API виджета. Список
принимаемых параметров и соответствующей их обработки задаётся в виджете с помощью статического свойства ``@params``.
Пример:

.. code-block:: coffee
  :linenos:

  @params:
    first: 'onFirstChange'
    second: (value) ->
      console.log 'second param came', value
      @ctx.set(second: value)
    third: ':ctx'
    fourth: ':ctx.fourVal'
    fifth: ':ignore'

Основной формат определения обработчика параметра --- указать фукнцию-обработчика, которая принимает на вход один
аргумент -- значение входящего параметра, либо в виде анонимной функции, либо в виде названия динамического метода
виджета (см. ``first`` и ``second`` в примере). При этом в обоих случаях функции будут выполняться в контексте
экземпляра виджета и в них доступны все динамические свойства виджета через ``this``.

Для распространённых случаев предусмотрены специальные значения обработчиков (синтаксический сахар):

* ``:ctx`` --- значение параметра будет записано в одноимённую переменную контекста.
* ``:ctx.someName`` --- значение параметра будет записано в переменную контекста с указанным именем, в данном случае
  ``someName`` (см. ``fourth`` в примере).
* ``:ignore`` --- параметр будет проигнорирован (см. комментарий ниже).

Если в виджет передаётся параметр, который отсутствует в ``@params``, то поведение зависит от конфигурационного
параметра ``strictWidgetParams``: если его значение ``true``, то будет брошено исключение и рендеринг виджета
прервётся, в противном случае параметр будет проигнорирован. Рекомендуется включать эту настройку в разработческой
конфигурации, чтобы вовремя находить ошибки, и выключать в продакшн системе.

Параметры могут "приходить" в виджет из трёх источников:

* Параметры в плагинах ``#widget`` или ``#extend`` в шаблоне родительского виджета. Зачастую, значения параметров
  связаны с переменными контекста родительского виджета и автоматически транслируются в дочерний виджет в случае
  изменения.
* Параметры, переданные разработчиком в методы behaviuor-класса ``insertChildWidget`` или ``initChildWidget`` при
  динамическом создании виджета из родительского.
* Параметры корневого виджета из роутера.

.. note::

  В CordJS параметры виджета не являются чем-то статическим (в отличие, например, от props в компонентах ReactJS),
  они никуда по-умолчанию не сохраняются. Их правильнее воспринимать в виде управляющих сигналов-импульсов, которые
  могут приходить в любом порядке и составе. Ни один из параметров не является обязательным.

  Это не сразу очевидно, но параметры не являются частью состояния виджета. Состояние виджета определяется только
  контекстом. Если значение входящего параметра нужно сохранить, разработчик должен явно сохранить его в
  соответствующую переменную контекста.


Совместная обработка нескольких параметров
------------------------------------------

В предущем разделе рассматривается только обработка входящих параметров по отдельности, однако бывают ситуации, когда
для получения целостной картины необходимо иметь значения нескольких параметров одновременно. Для таких случаев
предусмотрен специальный синтаксис:

.. code-block:: coffee
  :linenos:

  @params:
    'first,second,third': (first, second, third) ->
      if first
        @ctx.set(second: second)
        @ctx.set(third: third)  if third?
    'first, third': 'onFirstOrThirdChange'
    first: ':ctx'

Если в ключе в ``@params`` перечислено несколько названий через запятую (с пробелами или без), то соответствущая
функция-обработчик будет вызвана в случае, если в виджет "придёт" любой из перечисленных параметров.

Если какая-либо комбинация параметров "придёт" одновременно, то в функцию-обработчик будут переданы все пришедшие
параметры. *Одновременно* здесь означает, что параметры пришли синхронно в рамках javascript-тика, в котором был
отправлен первый параметр.

Если какой-либо параметр не пришёл, вместо него будет подставлено значение ``undefined``.

Один и тот же параметр может участвовать в нескольких таких "комбинациях", а также иметь свой отдельный обработчик
--- это не запрещено. В таком случае все функции-обработчики будут выполнены (порядок выполнения не определён).


Объявление CSS-зависимостей
===========================

Для прописывания стилей конкретно для данного виджета предназначен специальный stylus-файл, расположенный в папке
виджета, и называющийся так же, как и папка, но с расширением ``.styl``. Чтобы его подключить, необходимо в классе
виджета прописать динамическое свойство ``css``:

.. code-block:: coffee
  :linenos:
  :emphasize-lines: 3

  class SomeWidget extends Widget

    css: true

Часто виджет может использовать какие-либо внешние CSS-фреймворки, в этом случае следует явно перечислить список
зависимостей в том же свойстве ``css``:

.. code-block:: coffee
  :linenos:
  :emphasize-lines: 3-7

  class SomeWidget extends Widget

    css: [
      'someWidget'
      '/vendor/bootstrap/bootstrap'
      '/hello/common//anotherWidget/common'
    ]

При таком способе путь к CSS-зависимости может быть задан в одном из трёх форматов:

* **Относительный путь** --- для перечисления stylus-файлов из папки самого виджета.
* **Абсолютный путь к папке /vendor/** --- для указания зависимости от внешнего CSS-фреймворка или библиотеки. Должен
  начинаться с ``/vendor/``.
* **Канонический путь в формате CordJS** --- для указания зависимости от stylus- или css-файла в папке другого
  виджета. В таком пути должен присутствовать двойной слеш (``//``), может быть использован как абсолютный, так и
  относительный формат пути. Двойной слеш в данном случае при "раскрытии" заменяется на ``/widgets/``.

Расширение файлов стилей при перечислении зависимостей указывать не нужно.

.. note::

  CordJS автоматически обеспечивает загрузку CSS-файлов, от которых зависит виджет, до того момента, как на экране
  отобразится первый экземпляр виджета.


Корневой элемент виджета
========================

У всех виджетов, которые не "расширяют" какой-нибудь другой лейаут-виджет (т.е. в их шаблоне не используется
``#extend``), есть специальный корневод DOM-элемент, который создаётся автоматически фреймворкам и внутри которого
размещается весь контент виджета, отрендеренный из шаблона. Для управления свойствами корневого элемента в классе
виджета предусмотрено два динамических поля:

.. code-block:: coffee
  :linenos:
  :emphasize-lines: 3-7

  class SomeWidget extends Widget

    rootTag: 'span'
    cssClass: 'b-some-widget'

``rootTag`` --- название html-тега для корневого элемента. По-умолчанию это ``div``.

``cssClass`` --- строковое значение атрибута ``class`` корневого элемента (может быть перечислено несколько
названий css-классов через пробел).

Значение ``rootTag`` нельзя изменять динамически, тогда как ``cssClass`` можно изменять до момента первого рендеринга
виджета. Изменение свойства ``cssClass`` после рендеринга не будет иметь никакого эффекта в DOM до сделующего
полоного ре-рендера, когда корневой элемент будет пересоздан.

.. note::

  У виджетов, в которых используется ``#extend`` нет своего корневого элемента, однако ``#inline``-блоки, объявленные
  в нём, являются своего рода мини-корневыми элементами для его собственного контента. CordJS добавляет ``cssClass``
  к атрибутам ``class`` корневых DOM-элементов inline-блоков таких виджетов.


addDynClass
-----------

Для более предсказуемого динамического изменения css-классов корневого виджета следует использовать специальный метод
виджета ``addDynClass(cls)``. Он принимает на вход одиночное название класса и может вызываться несколько раз. Его
следует вызывать *только* в методе ``onShow``, а последующее динамическое управление классами осуществлять с помощью
методов ``addClass()``, ``removeClass()`` и ``toggleClass()`` в behaviour-классе виджета.


Работа с дочерними виджетами
============================

Дочерний виджет --- виджет, который порождён текущим (родительским) виджетом либо в процессе рендеринга
непосредственно его шаблона, либо динамически в коде его behaviour-класса.

Дочернему виджету может быть присвоено имя (name) --- уникальный ключ в рамках данного экземпляра родительского
виджета, с помощью которого можно идентифицировать данный дочерний виджет. Это удобный способ провести мостик и
связать код класса виджета и его шаблон.

Родительский виджет может обрашаться к дочерним посредством следующих свойств:

* ``children`` --- плоский массив экземпляров дочерних виджетов.
* ``childById`` --- те же дочерние виджеты, но виде объекта с уникальными идентификаторами дочерних виджетов в
  качестве ключей.
* ``childByName`` --- в этот объект попадают только "именованные" дочерние виджеты. Ключ --- название, значение ---
  виджет.

Главное предназначение этих свойств --- вызов публичных методов дочерних виджетов.

Важно понимать, что дочерние виджеты становятся доступны только после рендеринга шаблона, а не сразу после создания
экземпляра виджета.


Подписка на события дочерних виджетов
-------------------------------------

Единственным "легальным" способом для дочернего виджета активно "обратиться" к родительскому является генерация
события с помощью метода ``emit``. Каждый виджет является EmentEmitter'ом в понятиях Node.js, т.е. обладает
стандартными методами ``emit``, ``on``, ``off`` и т.д. В CordJS используется реализация `EventEmitter3
<https://github.com/primus/eventemitter3>`_.

Родительский виджет может подписаться на событие дочернего виджета и каким-либо образом на него среагировать. Это
можно делать, напрямую обращаясь непосредственно к экземпляру дочернего виджета и используя API EventEmitter, но это
довольно неудобно, поскольку дочерний виджет не всегда доступен и нужно не забывать вовремя отписываться от событий.
Для "правильной" организации подписок следует использовать декларативный подход посредством статическоко свойства
``@childEvents``. В этом случае CordJS сам позаботиться о своевременной подписке/отписке в самый подходящий
момент. Пример:

.. code-block:: coffee
  :linenos:
  :caption: public/bundles/hello/example/widgets/parent/Parent.coffee
  :emphasize-lines: 3,4

  class Parent extends Widget

    @childEvents:
      'button click': (childCounter) ->
        console.log 'The button clicked', childCounter

.. code-block:: html
  :linenos:
  :caption: public/bundles/hello/example/widgets/parent/parent.html
  :emphasize-lines: 3

  <div>
    <input type="text" placeholder="some value" value=""/>
    {#widget type="//Child" name="button" /}
  </div>

.. code-block:: coffee
  :linenos:
  :caption: public/bundles/hello/example/widgets/child/Child.coffee
  :emphasize-lines: 5

  class Child extends Widget

    @initialCtx:
      counter: 0

    # допустим, этот метод вызывается, когда пользователь нажимает кнопку в виджете Child
    handleButtonClick: ->
      @ctx.set('counter', @ctx.counter + 1)
      @emit 'click', @ctx.counter

Формат свойства ``@childEvents`` следующий:

* Ключ --- разделённые пробелом два слова:

  * Первое слово (``button``) --- название дочернего виджета (см. атрибут ``name`` у виджета ``Child`` в шаблоне
    ``parent.html``), на событие которого нужно подписаться. Поддерживается специальное значение ``:any``, которое
    означает, что нужно подписаться на событие с заданным названием для всех дочерних виджетов.
  * Второе слово (``click``) --- название события, на которое нужно подписаться (см. строчку с ``@emit`` в классе
    ``Child``).

* Значение --- либо анонимная функция-обработчик, либо название метода виджета, который будет вызван, если дочерний
  виджет бросит событие с указанным названием. В качестве аргумента фукнции-обрарботчику будет передан payload
  события (второй аргумент функции ``emit``). Обработчик будет выполняться в контексте экземпляра родительского
  виджета.


Свойство ``behaviuorClass``
===========================

Bahaviour-класс виджета автоматически подключается, если в папке виджета присутствует coffee-файл с суффиксом
``Behaviour`` к названию виджета. В некоторых случаях может понадобиться отключить behaviour-класс, даже если он
присутствует. Этого можно добиться, выставив значение свойства ``behaviourClass`` в ``false``.

.. code-block:: coffee
  :linenos:
  :caption: public/bundles/hello/example/widgets/someWidget/SomeWidget.coffee
  :emphasize-lines: 5

  class SomeWidget extends Widget

    behaviourClass: false

.. note::

  Если класс виджета отнаследован от другого виджета, у которого есть behaviour-класс, а сам behaviour-класс не
  переопределён (файл не создан), то будет автоматически использован behaviour-класс родительского виджета.


Публичные API-методы
====================

В виджете можно объявлять публичные методы --- методы, которые предназначены для использования извне родительскими
виджетами для чтения данных из дочернего виджета, вызова какого-либо динамического поведения или изменения
внутреннего состояния. Никаких специальных требований к таким методам нет, кроме обычных требований к
программированию публичных методов:

* Должно быть чётко обозначено, что это публичное API виджета. Метод должен называться без символа подчёркивания
  вначале. Лучше группировать все такие методы вместе.
* Метод должен быть документирован.

.. warning::

  Доступ к состоянию виджета как на чтение, так и на запись извне должен осущетсвляться только через публичные методы.
  Практика обращения к контексту виджета напрямую скорее всего приведёт к проблемам с дальнейшей поддержкой и
  модификацией кода.
