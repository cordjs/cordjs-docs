*********************************************
API работы с состоянием (контекстом)  виджета
*********************************************

Контекст (Context) --- специальный тип (класс) для хранения состояния виджета. Он умеет хранить простые скалярные
типы, массивы, нетипизированные объекты, а также модели и коллекции CordJS. Точнее говоря, в контекст можно записать
любые данные, но  во время цикла сериализации/десериализации при передаче с сервера в браузер данные, которые
контекст "не умеет" корректно обрабатывать, будут либо искажены, либо потеряны.

Индивидуальный экземпляр контекста доступен в каждом виджете через динамическое свойство ``ctx``. Помимо заданных
разработчиком данных, в контексте всегда есть поле ``id`` в котором содержится уникальный строковой идентификатор
виджета.

Этот раздел посвящён довольно простому API контекста.

Запись
======

``@ctx.set`` --- запись данных в контекст
-----------------------------------------

Добавление/изменение полей контекста осуществляется посредством метода ``set``. Существует два варианта использования:

* На входе один аргумент-объект, у которого ключи --- названия переменных контекста, значения --- соответствующие
  новые значения. С помощью этого варианта можно изменить несколько переменных контекста за один вызов.
* На входе два аргумента: первый --- строковое название переменной контекста, второй --- новое значение для этой
  переменной. Так можно изменить значение только одной переменной, но такой способ значительно удобнее, если само
  название переменной контекста является динамическим и лежит в другой переменной.

Примеры:

.. code-block:: coffee
  :linenos:

  @ctx.set(first: 'some string value')
  @ctx.set
    first: 'some string value'
    second: 123

  @ctx.set('first', 'some string value')
  ctxVarName = 'first'
  @ctx.set(ctxVarName, 'some string value')

Метод ``set`` возвращает булево ``true``, если в результате его работы было изменено значение хотя бы одной
переменной контекста, иначе --- ``false``.

.. warning::

  Если в качестве значения переменной передано ``undefined``, то переменная сохранит своё старое значение и **не**
  будет изменена. Если нужно сбросить значение, используйте ``null``.

.. _setWithFeedback:

``@ctx.setWithFeedback`` --- запись с обратной связью (deprecated)
------------------------------------------------------------------

В редких случаях необходимо получить обратную связь от behaviour-класса, когда он обработал изменение переменной
контекста. Для реализации такого сценария можно использовать метод ``setWithFeedback``. Он принимает на вход два
аргумента: строковое название переменной контекста и её новое значение (так же, как и один из вариантов ``set``), но
возвращает *промис*, который резолвится тогда, когда behaviour-класс обработал и отреагировал на данное изменение.
При этом разработчик может управлять тем, в какой момент этот промис разрешится. Лучше один раз увидеть:

.. code-block:: coffee
  :linenos:

  # в коде виджета
  @ctx.setWithFeedBack('first', newValue).then ->
    console.log 'the new value shown'

  # в коде behaviour-класса
  @widgetEvents:
    first: (data) ->
      data.callbackPromise.when(@render())

В примере ``console.log`` произойдёт только после того, как выполниться операция ``@render()``, т.е. полная
перерисовка виджета.

.. warning::

  ``setWithFeedback`` --- устаревший метод, его не следует использовать в новом коде. Подобного эффекта легко
  добиться, просто научившись работать с промисами.


Чтение переменных контекста
===========================

Чтение переменных контекста происходит посредством обыкновенного доступа к полю объекта ``ctx`` с названием переменной:

.. code-block:: coffee

  x = @ctx.first + @ctx.second

При этом добавлять/изменять переменные контекста прямым доступом к полю нельзя, поскольку в этом случае не сработают
внутренние механизмы оповещения об изменении, которые очень важны для корректной работы CordJS. Для записи следует
всегда использовать метод ``set``.


``@ctx.isEmpty`` --- проверка на пустое значение
------------------------------------------------

Метод ``isEmpty`` принимает название переменной контекста и возвращает ``true`` в одном из следующих случаев:

* переменная отсутствует в контексте,
* переменная имеет значение ``undefined`` или ``null``,
* переменная имеет значение ``:deferred``, т.е. *отложенное* (см. ниже).

В остальных случаях метод возаращает ``false``.


Отложенные значения переменных (поддержка асинхронности)
========================================================

Поскольку CordJS --- фронтенд-фреймворк, ориентированный на получение данных через REST API, то есть через сетевые
запросы вовне, то данные, получаемые и отображаемые виджетом, могут быть доступны не сразу (синхронно), а через
некоторое время после запроса (асинхронно). Контекст виджета реализует ключевые механизмы для поддержки оптимального
рендеринга шаблона виджета по мере поступления данных.

Сам процесс изначального рендеринга виджета запускается сразу после (синхронной) обработки входящих параметров
виджета и метода ``onShow``. Это делается для того, чтобы ускорить процесс рендеринга шаблона, т.е. не тормозить
рендеринг большого виджета из-за того, что не готова какая-либо переменная, от которой зависит только малая его часть.

Для поддержки такого поведения переменная контекста может иметь специальное *отложенное* (deferred) значение. Когда
шаблонизатор (вернее специальные плагины CordJS для Dust.js) "видит" отложенное значение переменной, он начинает
*слушать* событие по изменению данной переменной и продолжает рендеринг этого фрагмента сразу после того, как
переменной выставлено актуальное значение. При этом рендеринг остальных фрагментов шаблона, которые не зависят от
отложенной переменной, продолжается конкурентно. Таким образом, скорость рендеринга всего шаблона зависит от времени
поступления самой медленной отложенной переменной, а не от суммы таких времён.

Специальное значение, которое означает, что переменная контекста имеет *отложенное* значение --- строка ``:deferred``.
Переменную контекста можно пометить как *отложенную* одним из сделующих способов:

* вызов метода ``setDeferred`` или ``setServerDeferred``,
* использовать значение ``':deferred'`` при использовании метода ``set``,
* присвоить переменной значение-промис при использовании метода ``set`` **(рекомендовано)**.


``@ctx.setDeferred`` и ``@ctx.setServerDeferred`` --- пометить переменную как *отложенную* (deprecated)
-------------------------------------------------------------------------------------------------------

Метод ``setDeferred`` принимает на вход переменное количество аргументов --- строковые названия переменных контекста,
значения которых следует сделать отложенными.

``setServerDeferred`` отличается только тем, что он работает только на стороне сервера (Node.js), в браузере он
ничего не делает. Это удобно в некоторых ситуациях, но его использования лучше стараться избегать.

Рассмотрим пример использования отложенных значений:

.. code-block:: coffee
  :linenos:

  class SomeWidget extends Widget

    @inject: ['api']

    @initialCtx:
      userId: 0
      user: {}
      userName: ''

    @params:
      'userId': (userId) ->
        @ctx.set
          userId: userId
          user: ':deferred'

        @ctx.setDeferred('userName')

        @api.get("/user/#{userId}").then (user) =>
          @ctx.set
            user: user
            userName: user.name
        .catch (err) =>
          @ctx.set
            user: {}
            userName: ''
            error: err.message

Общий алгоритм таков --- сначала синхронно(!) в обработчике параметра или в ``onShow`` выставляется
deferred-значение, а затем после завершения асинхронной операции (в данном случае API-запроса) выставить конечное
значение переменной контекста.

.. warning::

  Важно пометить переменную отложенной именно сразу (синхронно). Если этого не сделать, шаблонизатор не "поймёт", что
  переменная ещё не готова и шаблон отрендерится с пустым значением. Обратите на это внимание, это один из моментов,
  в котором часто совершают ошибки.

.. warning::

  При таком подходе важно обеспечить, чтобы отложенная переменная в конечном итоге получила какое-либо "неотложенное"
  значение, иначе рендеринг виджета зависнет навсегда и пользователь увидит бесконечную загрузку.


Установка промиса в качестве значения переменной контекста
----------------------------------------------------------

Альтернативный (и предпочтительный) способ работы с отложенными переменными контекста --- присваивать в качестве
значения *промис*. В этом случае, если промис ещё не отрезолвлен, то переменной автоматически присваивается значение
``:deferred``, а когда промис получит своё значение, то это значение будет автоматически присвоено отложенной
переменной. При этом добавляется существенное преимущество: если промис завершится ошибкой, то в отличие от "ручного"
управления deferred-переменными, CordJS "поймёт", что рендеринг виджета невозможен и соответствующим образом
обработает ошибку --- зависания рендеринга в случае ошибки исключены.

Пример, аналогичный предыдущему может быть записан так:

.. code-block:: coffee
  :linenos:

  @params:
    'userId': (userId) ->
      userPromise = @api.get("/user/#{userId}")
      @ctx.set
        userId: userId
        user: userPromise
        userName: userPromise.then (user) -> user.name

В некоторых случаях может понадобиться сохранить в переменную контекста сам промис без дополнительной обработки. Для
таких случаев предусмотрен лайфхак --- необходимо назвать переменную контекста с суффиксом ``Promise``. В этом случае
переменная не будет обрабатываться как отложенная, а просто получит указанный промис как значение:

.. code-block:: coffee
  :linenos:

  @ctx.set('usersPromise', @api.get('/users'))
  usersCountPromise = @ctx.usersPromise.then (users) -> users.length

.. warning::

  Присвоение промиса в чистом виде следует использовать с осторожностью. Контекст не сможет корректно
  сериализовать/десериализовать промис, поэтому при передаче с сервера на клиент значение будет потеряно. Такое
  использование допустимо только на стороне браузера, когда сериализации контекста не происходит.


``@ctx.isDeferred`` --- проверка на "отложенность"
--------------------------------------------------

Метод ``isDeferred`` Принимает на вход название переменной контекста. Возвращает ``true``, если её текущее значение
*отложенное*, иначе --- ``false``. Удобный аналог выражению ``@ctx.someVar == ':deferred'``.


``@ctx.getPromise`` --- получить значение отложенной переменной в Promise-обёртке
---------------------------------------------------------------------------------

Метод ``getPromise`` принимает на вход название переменной контекста и возвращает её значение, завёрнутое в промис.
Если значение переменной отложенное, то возвращённый промис отрезолвится, когда переменная получит "нормальное"
значение. Метод может оказаться полезным для выстраивания асинхронных цепочек при грамотной работе с промисами.


Особенности внутренней работы контекста
=======================================

Контекст --- это не просто хранилище переменных, которые можно сериализовать/десериализовать. Кроме хранения он
осуществляет функцию оповещения заинтересованных слушателей об изменении значения тех или иных переменных. Основными
слушателями являются behaviour-инстанс виджета и дочерние виджеты, параметры которых зависят от переменных контекста.

Изменение переменной приводит к возникновению события, которое передаётся по шине ``postal``. Название (topic)
события формируется по шаблону ``widget.<ID виджета>.change.<название переменной>``. Событие генерируется асинхронно
относительно вызова ``@ctx.set`` и содержит payload-объект со следующими полями:

* ``name`` --- название переменной контекста.
* ``value`` --- новое значение.
* ``oldValue`` --- предыдущее значение.
* ``callbackPromise`` --- для поддержки :ref:`setWithFeedback <setWithFeedback>`.
* ``cursor`` --- специальный уникальный идетификатор, предназначенный для поддержки stash-режима работы контекста
  (см. пояснение ниже) и определения событий-дубликатов.
* ``version`` --- инкрементная целочисленная версия контекста, которая увеличивается при изменении каждой переменной.
  Она также используется для внутренней синхронизации событий, доходящих до behaviour'а, но в обратную сторону ---
  помогает игнорировать события об изменениях, которые и так уже присутствовали в контексте на момент рендеринга
  шаблона и их повторная обработка в behaviour'е может привести к лишней перерисовке.

Stash-режим работы контекста --- это когда события об изменениях не отправляются сразу и накапливаются, а отправляются
позже при возникновении нужного момента. Он необходим из-за асинхронной природы создания экземпляра behaviour'а,
чтобы не потерять события изменения, которые могут возникнуть после того, как рендеринг шаблона уже закончился, но
behaviour ещё не создан. Для управления этим режимом используются методы  ``stashEvents`` и ``replayStashedEvents``.
Это исключительно внутренние методы фреймворка и не должны использоваться в пользовательском коде.
