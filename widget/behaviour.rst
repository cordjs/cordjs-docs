***********************************
Класс-поведение виджета (behaviour)
***********************************

Класс-поведение виджета не является обязательным артефактом виджета, однако многие динамические возможности на
стороне браузера можно реализовать только в нём. Файл с исходниками класса должен располагаться в папке виджета и
называться так же, как и файл самого виджета, но с суффиксом ``Behaviour``. Behaviour-класс предназначен для решения
двух основных задач:

* Динамическая синхронизация отображения виджета и его состояния (после первичного рендеринга).
* Обработка пользовательских DOM-событий.

Для реализации обоих задач в CordJS активно используются возможности библиотеки `jQuery <http://jquery.com/>`_.

В процессе разработки может возникнуть желание писать в классе-поведении код, непосредственно управляющий состоянием
виджета, но этого следует избегать. Если в ответ на пользовательское событие необходимо изменить состояние виджета,
то следует из обработчика события вызвать метод главного класса виджета, который изменит контекст (в экземпляре
behaviour-класса есть ссылка на собственный виджет посредством динамического поля ``@widget``).

.. warning::

  **ВАЖНО!!!** В архитектуре виджета первичны состояние и шаблон, отображение следует за ними. Если пользовательское
  действие должно привести к изменению внешнего вида, то необходимо сначала изменить состояние виджета, а
  затем изменение состояния приведёт и изменению отображения посредством обработчиков ``@widgetEvents``.

  Только таким образом можно добиться целостности виджета. В противном случае, если состояние не соответствует
  отображению, то полная перерисовка виджета приведёт к неожиданным результатам.

  Изменять DOM-представление виджета прямо в обработчиках пользовательских событий, не синхронизируя с состоянием
  виджета --- одна из наиболее частых ошибок новичков в CordJS и основная причина неожиданных и трудноотлаживаемых
  ошибок при дальнейшей поддержке приложения.

Типичный behaviour-класс виджета выглядит вот так:

.. code-block:: coffee
  :linenos:
  :caption: public/bundles/hello/example/widgets/currentTime/CurrentTimeBehaviour.coffee

  define [
    'cord!Behaviour'
  ], (Widget) ->

    class CurrentTimeBehaviour extends Behaviour

      @inject: ['moment']  # сервис @moment не используется, указан только для примера @inject

      @widgetEvents:
        time: 'onTimeChange'
        zone: 'render'

      @events:
        'click @updateButton': ->
          @widget.updateTime()

      updateButton: @$('.button')
      timeContainer: @$('.time')


      init: ->
        # автообновление раз в минуту
        @updateIntervalId = setInterval =>
          @widget.updateTime()
        , 60000


      destroy: ->
        clearInterval(@updateInvervalId)


      onTimeChange: (data) ->
        @timeContainer.html(data.value)


Внедрение зависимостей (Dependency Injection)
=============================================

DI посредсвом статического свойства ``@inject`` работает абсолютно аналогично главному классу виджета. См.
:ref:`widget-di` в мануале по классу виджета.


Понятие собственного DOM-пространства виджета и методы работы с ним
===================================================================

Behaviour-класс должен работать в рамках собственной разметки виджета и стараться "не трогать" разметку других
виджетов.

В случае простого виджета, в шаблоне которого не используется ``#extend``, собственным DOM-пространством
виджета является всё содержимое его корневого элемента. При этом внутренняя разметка дочерних виджетов исключается,
но корневые элементы дочерних виджетов в плане позиционирования вполне могут управляться родительским.

В случае, когда шаблон виджета использует ``#extend`` и ялвяется частью лейаут-структуры, у него нет единого
корневого элемента и собственной разметкой является только разметка inline-блоков, объявленных в шаблоне виджета.

Корневой элемент в виде jQuery-объекта для простых виджетов доступен через динамическое свойство ``@el``. Для сложных
"расширенных" виджетов ``@el`` пустой, а вероятно многочисленные корневые элементы inline-блоков объединены в
jQuery-объекте в динамическом свойстве ``@$rootEls``. Если корневой элемент есть, то он также добавляется в свойство
``@$rootEls``.


Метод ``@$('selector')`` (jQuery)
---------------------------------

В процессе DOM-манипуляций часто нужно обращаться к элементам виджета через CSS-селекторы. Для поиска элемента в
рамках вышеописанного DOM-пространства виджета, следует использовать динамический метод ``@$``, который является
proxy-методом к jQuery в контексте корневых элементов виджета:

.. code-block:: coffee
  :linenos:
  :emphasize-lines: 2

  onTimeChange: (data) ->
    @$('.time-content').html(data.value)

.. _behaviour-named-elements:

Объявление именованых селекторов элементов - ``@elements``
----------------------------------------------------------

Если какой-либо jQuery-селектор используется несколько раз, то имеет смысл его "закешировать". Для этого в
behaviour-классе можно объявить именованный селектор следующим образом:

.. code-block:: coffee
  :linenos:

  class SomeWidgetBehaviour extends Behaviour

    # современный способ
    button: @$('.button')

    # устаревший (deprecated) способ
    @elements:
      '.button': 'button'

В примере представлены два способа сделать одно и то же, но первый предпочтительнее. В результате, после
инициализации виджета в динамическом свойстве ``button`` будет лежать готовый jQuery объект с селектором ``.button``
отработавшим в рамках корневого элемента виджета. Его можно будет использовать в любом методе behavour'а, а также в
обработчиках событий. Кроме того, на такие именованные элементы можно ссылаться в свойстве ``@events`` для подписки
на события этих элементов (:ref:`см. ниже <behaviour-events>`).

.. note::

  Обратите внимание, что при объявлении именованного элемента в первом случае используется статический метод ``@$``,
  который отличается от динамического ``@$``, описанного в предыдущем подразделе.

В редких случаях в результате DOM-манипуляций закешированный именованный элемент может "устареть" --- указывать на
уже несуществующий в DOM-дереве элемент. В таких случаях можно вызвать метод ``@refresElements()``, чтобы обновить
все объявленные именованные элементы.


Обработка событий изменения состояния (контекста) виджета - ``@widgetEvents``
=============================================================================

После формирования первоначального состояния и первичного рендеринга шаблона виджет продолжает "жить" и его состояние
может быть изменено либо вследствие действий пользователя, либо из-за вновь пришедших параметров от родительского
виджета. Одна из задач behaviour-класса --- обеспечить корректное обновление DOM-представления виджета в соответствие
с изменением его состояния (контекста).

Реакция на изменения переменных контекста задаётся с помощью статического свойства ``@widgetEvents``, которое
представляет собой объект, ключами которого являются названия переменных контекста, а значениями --- callback-функции,
которые должны выполниться, когда пришло событие об изменении соответствующей переменной.

Как и в других подобных случаях в CordJS, callback-функция может заваться либо в виде анонимной функции прямо на
месте, либо в виде строки-названия динамического метода класса. В обоих случаях функция будет выполнена в
контексте экземпляра behaviour-класса.

Функции-обработчику передаётся единственный аргумент --- структура, которую создаёт объект-контекст виджета,
описанная в разделе :ref:`context-internals`. С точки зрения кода конечного behaviour-класса интерес представляют
только поля ``value`` и ``oldValue``. Остальные поля в новом коде использовать не следует.

.. _behaviour-events:

Обработка DOM-событий - ``@events``
===================================

С помощью статического свойства ``@events`` можно подписаться на DOM-событие любого элемента внутри виджета. Формат
свойства ``@events`` следующий:

* Ключ --- разделённые пробелом два части:

  * Первое слово (например, ``click``) --- название DOM-события, на которое нужно подписаться.
  * Остальная часть (например, ``.content .button``) --- jQuery-селектор элемента(ов) на событие которого(ых) нужно
    подписаться. Этот селектор не является "абсолютным", а работает только в контексте корневого элемента виджета.
    Таким образом, невозможно подписаться на событие элемента "чужого" виджета. Технически возможно подписаться на
    событие дочернего виджета, но этого никогда не следует делать, поскольку нарушается инкапсуляция. Если селектор
    начинается с "собачки" (``@``), то он интерпретируется как ссылка на :ref:`именованный элемент
    <behaviour-named-elements>`.

* Значение --- либо анонимная функция-обработчик, либо название метода behaviour'а, который будет вызван, если дочерний
  виджет бросит событие с указанным названием. В качестве аргумента фукнции-обработчику будет передан обычный DOM
  event. Обработчик будет выполняться в контексте экземпляра behaviour-класса.

.. note::

  Полезно понимать, что фактически событие привязывается к корневому элементу виджета и используется механизм
  делегирования события из jQuery. Напрямую на указанный в селекторе элемент вешается только событие ``scroll``,
  поскольку его делегирование невозможно (оно не "всплывает").


Функции-колбеки жизненного цикла behaviour'а
============================================

В behaviour-классе можно объявить несколько специальных динамических методов, автоматически выполняющихся на
различных этапах жизненного цикла behaviour'а.


``init``
--------

Метод ``init`` выполняется сразу после того, как объект-поведение создан и в него внедрены зависиомсти, описанные в
свойстве ``@inject``, но до того, как производится подписка на события из ``@widgetEvents`` и ``@events``.

В методе можно описать дополнительную инициализацию, запустить таймеры, подписаться на события, на которые невозможно
подписаться с помощью декларативных методов описанных выше.

.. warning::

 Если метод ``init`` возвращает промис, то дальнейшая инициализация behaviour'а продолжится только после того, как
 промис будет разрешён. Если промис завершится ошибкой, то и процесс инициализации виджета завершится этой ошибкой.

.. _behaviour-show:

``show``
--------

В большинстве случаев инициализация экземпляра behaviour-класса виджета происходит в тот момент, когда пользователь
ещё не видит виджет на экране. Так сделано для того, чтобы пользователь сразу "получал" работоспособный элемент
интерфейса. Однако некоторые инициализирующие операции невозможно провести с отвязанным (detached) DOM-элементом,
например, проскроллить на определённую позицию можно только видимый на экране элемент.

Для подобных действий предусмотрен специальный callback --- ``show``. Он выполняется сразу после того, как виджет
появился в основном DOM-дереве документа. Для виджетов, которые пришли вместе со страницей, отрендеренной на сервере,
``show`` вызывается сразу после начальной инициализации behaviour-класса в браузере.

Здесь следует выполнять только те операции, которые невозможно выполнить в ``init``. ``show`` гарантировано выполняется
после ``init``.

Если виджет переписовывается полностью, метод ``show`` выполняется заново.


``destroy``
-----------

Метод ``destroy`` является антиподом ``init`` и выполняется непосредственном перед уничтожением экземпляра
behaviour-класса. Не путайте с уничтожением виджета, поскольку при переписовке живого виджета его behaviour
уничтожается и создаётся заново.

В методе следует освободить ресурсы, "занятые" в ``init`` и, возможно, в ``show`` --- очистить таймеры, отписаться от
событий и т.п.


Методы для полной перерисовки виджета
=====================================

Самый простой способ синхронизировать представление с состоянием виджета --- полностью перерисовать его, отрендерив
заново шаблон и заменив старый DOM-элемент на новый. Это довольно "тяжёлая" в плане производительности операция,
однако в некоторых случаях это предпочтительнее ручного манипулирования DOM-деревом. Для реализации подобного
сценария у behaviour-класса имеются два динамических метода: ``render()`` и ``renderInline()``.


render
------

Если у виджета есть корневой элемент (он не является "расширенным"), то его можно полностью переписовать с помощью
метода ``render``, указав его в качестве обработчика в ``@widgetEvents`` или вызвав напрямую в любом другом месте.

Вызов ``render`` приводит к следующему:

1. Уничтожается текущий экземпляр behaviour-класса (происходит отписка от всех событий, вызывается метод ``destroy``,
   если объявлен).
2. Уничтожаются все дочерние виджеты.
3. Шаблон виджета рендерится заново, создаётся новый корневой элемент виджета.
4. Создаётся новый экземпляр behaviour-класса, вызывается метод ``init``, заново происходит привязка событий.
5. Старый корневой элемент виджета заменяется на новый. Вызывается метод ``show``.

Метод ``render`` возвращает промис, который резолвится новым экземпляром behaviour-класса, когда весь процесс
перерисовки завершится.


renderInline
------------

Для переписовки inline-блоков виджетов, у которых нет собственного корневого элемента, можно использовать метод
``renderInline()``. Метод принимает на вход название inline-блока, поэтому для того, чтобы им воспользоваться, нужно
явно указать название блока в шаблоне посредством параметра ``name``.

Вызов ``renderInline`` перерисовывает только указанный inline-блок, не разрушает текущий экземпляр behaviour-класса.
Он также возвращает промис, который резолвится, когда переписовка завершена.

.. warning::

  Работа метода ``renderInline`` не отлажена до конца, поэтому его использования следует избегать. Более-менее
  корректно он работает только в том случае, если inline-блок у виджета единственный. Если возникает необходимость
  перерисовывать inline-блок, завернуть его содержимое в отдельный виджет.

.. _behaviour-root-css-class:

Методы для работы с CSS-классами корневого элемента виджета
===========================================================

Поскольку корневой элемент виджета не является частью его шаблона, а автоматически управляется фреймворком, никогда
не следует изменять его атрибуты напрямую через обращение к ``@el``. Для корректного управления CSS-классами
корневого элемента, наряду с методом ``addDynClass`` главного класса виджета, в behaviour-классе предусмотрены три
динамических метода, полностью повторяющие API jQuery: ``@addClass()``, ``@removeClass()`` и ``@toggleClass()``. Для
синхронизации корневого класса виджета с изменённым состоянием следует использовать только их.


Методы для динамического создания/удаления дочерних виджетов
============================================================

В сложных динамических интерфейсах часто возникает ситуация, когда изменение состояния приводит к необходимости
создавать новые дочерние виджеты. Базовый класс ``Behaviour`` предоставляет необходимые методы для этой задачи.


``insertChildWidget``
---------------------

Метод ``insertChildWidget`` выполняет полный спектр действий --- от создания нового виджета, до вставки в нужное
место в DOM-дереве родительского виджета. Его использование является предпочтительным, поскольку не требует от
разработчика никаких дополнительных действий по обеспечение целостности работы виджета.

Метод принимает на вход два аргумента:

* *Строка* ``type`` --- канонический путь к классу создаваемого виджета в формате ``cord-w`` (как в :ref:`#widget`).
* *Объект* ``params`` --- параметры, передаваемые виджету плюс специальные параметры, определяющие, как он будет
  вставляться:

  * *jQuery* ``:context`` --- jQuery-объект с элементом, в который или вместо которого (в зависимости от значения
    параметра ``:position``) будет добавлен корневой элемент создаваемого дочернего виджета. По умолчанию это
    корневой элемент текущего (родительского) виджета.

  * *Строка* ``:position`` --- определяет, каким образом корневой элемент создаваемого виджет будет добавлен к
    элементу, указанному в параметре ``:context``. Может принимать следующие значения:

    * ``append`` --- добавить внутрь контекстного элемента самым последним. Это значение по умолчанию.
    * ``prepend`` --- добавить внутрь контекстного элемента самым первым.
    * ``replace`` --- заменить контекстный элемент.

  * *Строка* ``name`` --- название дочернего виджета, если требуется.

Пример:

.. code-block:: coffee
  :linenos:

  onItemAppend: (data) ->
    @insertChildWidget '//Item',
      item: data.value
      ':context': @$('.list')
      ':position': 'prepend'
    .spread (newEl, newWidget) ->
      console.log 'child widget created', newWidget.debug(), newEl

Метод возвращает промис, который резолвится массивом с двумя элементами (туплом):

* Первый --- jQuery-объект с корневым элементом нового виджета.
* Второй --- собственно сам новый виджет (экземпляр главного класса виджета).


``initChildWidget``
-------------------

Метод ``initChildWidget`` является болеее низкоуровневым, т.к. он только создаёт виджет, но не вставляет его в
DOM-дерево родительского виджета, предоставляя возможность сделать это разработчику в тот момент и так, как ему
захочется.

Метод принимает следующие параметры:

* *Строка* ``type`` --- канонический путь к классу создаваемого виджета в формате ``cord-w`` (как в :ref:`#widget`).
* *Строка* ``name`` --- название создаваемого дочернего виджета, если требуется. Этот параметр можно опустить.
* *Объект* ``params`` --- параметры, передаваемые создаваемому виджету.

Так же, как и ``insertChildWidget``, метод возвращает промис с туплом из корневого элемента и самого дочернего
виджета. Однако в отличие от предыдущего метода, корневой элемент отвязан (detached) от DOM-дерева
документа/родительского виджета и его следует добавить вручную:

.. code-block:: coffee
  :linenos:
  :emphasize-lines: 7,8

  onItemAppend: (data) ->
    @initChildWidget '//Item',
      item: data.value
      ':context': @$('.list')
      ':position': 'prepend'
    .spread (newEl, newWidget) ->
      DomHelper.append(@$('.list'), newEl).then ->
        newWidget.markShown()
        console.log 'child widget created', newWidget.debug(), newEl

Добавление в DOM-дерево следует производить не просто манипуляциями через jQuery, а через специальную утилиту. Это
связано с тем, что добавление элемента в DOM-дерево не является синхронной операцией, проходит некоторое время после
того, как вызов jQuery-метода уже завершился, прежде чем элемент на самом деле появится в DOM-дереве. Вызов метода
``markShown()`` у виджета, который следует тоже обязательно выполнить вручную при использовании ``initChildWidget``,
приводит в вызову колбека ``show`` (:ref:`см. выше <behaviour-show>`). Если этот метод выполнится раньше, чем
DOM-элемент действительно показан пользователю, то некоторые действия (например, скролл), выполняемые им, не смогут
исполниться.

Утилита ``DomHelper`` доступна по пути ``cord!utils/DomHelper`` и реализует функции ``append``, ``prepend`` и
``replace``. Каждая функция принимает два аргумента: первый --- jQuery-объект **куда** добавлять, второй ---
jQuery-объект **что** добавлять. Функции возвращают промис, который завершается, когда DOM-элемент действительно
добавлен или заменён. Реализовано с помощью технологии *Mutation Observer*.


``dropChildWidget``
-------------------

Метод ``dropChildWidget`` принимает на вход объект виджета (экземпляр главного класса) и уничтожает его, удаляя из
списка дочерних виджетов текущего виджета. Метод не удаляет DOM-элемент виджета, это следует сделать вручную с
помощью DOM-манипуляций.


Зачем понадобился ещё один один класс для виджета?
==================================================

В процессе разработки виджетов вы можете задать себе вопрос --- а зачем нужно было разделять виджет на 2 класса? Это
справедливый вопрос, поскольку тут мы имеем дело со связню один-к-одному, что не добавляет гармонии в мире :)

Главная причина, из-за которой было принято такое решение --- необходимость из кода behaviour-класса постоянно
обращаться к DOM и jQuery, которые недоступны (во всяком случае, без ненужных хаков) в Node.js, на котором происходит
серверный рендеринг. Behaviour-класс никак не участвует в работе серверной части проекта на CordJS.

С одной стороны было бы удобно, если бы класс был один. Но с другой --- есть преимущество в том, что код, выполняющий
разные функции, разнесён по разным файлам, и, как следствие, мы имеем более компактные и читабельные исходные файлы.
