*************************
Обзор подсистемы виджетов
*************************

**Виджет** --- программная абстракция, представляющая какую-либо обособленную единицу (крупную или мелкую)
пользовательского интерфейса. В CordJS всё, что видит пользователь, является частью какого-либо виджета, будь то
страница целиком или поле для ввода телефона. Виджеты компонуются друг с другом посредством использования одного
виджета в шаблоне (разметке) другого виджета.


Виджет в исходниках
===================

С точки зрения исходных кодов, виджет представляет собой подпапку любого уровня в папке ``widgets`` в корне любого
бандла. Папка должна называться со строчной буквы в горбатой нотации латинскими буквами и цифрами (например,
``someWidget``) и содержать следующие файлы:

* ``SomeWidget.coffee`` --- файл, в котором объявлен класс непосредственно виджета. Должен называться, как папка, но
  с заглавной буквы. Единственный обязательный файл, остальные могут отсутствовать.
* ``someWidget.html`` --- файл шаблона виджета в формате dust.js. Называется так же, как и папка с расширением ``
  .html``. Может отсутствовать, если класс виджета наследуется от другого виджета, у которого есть шаблон.
* ``SomeWidgetBehaviour.coffee`` --- файл, в котором объявлен behaviour-класс виджета, отвечающий за его динамическое
  поведение в браузере. Подобное название (c суффиксом ``Behaviour``) является правилом по-умолчанию и может быть
  изменено с помощью свойства ``behaviourClass`` в классе виджета.
* ``someWidget.styl`` --- файл CSS-стилей виджета. Подключается, если свойство ``css`` в классе виджета выставлено в
  ``true``, однако разарботчик может задать любой список подключаемых css-файлов с помощью того же свойства.

Папка виджета может быть включена в папку другого виджета. Это особенно удобно, если "внутренний" виджет используется
только в шаблоне "внешнего", то есть является дочерним.


Композиция против наследования
==============================

Виджеты могут быть взаимосвязаны двумя способами, которые не следует путать:

* **Наследование** --- это когда класс одного виджета наследуется от класса другого виджета в понятиях :abbr:`ООП
  (Объектно-ориентированное программирование)`. Обычно это удобно, когда нужно получить почти такой-же виджет, но
  немножко с другим внешним видом или поведением.
* **Композиция** --- это когда один виджет используется в шаблоне другого виджета. Это может быть либо через
  dust-плагин ``#widget``, либо через ``#extend``. В этом случае первый виджет (вернее, его экземпляр) включается в
  список дочерних виджетов второго (родительского). Родительский виджет "знает" о своих дочках и может иметь к ним
  прямой доступ (посредством публичных методов). Дочерние виджеты ничего не "знают" о родительском виджете и не
  должны делать об этом никаких предположений, поскольку ничто не запрещает использовать их в разных родительских
  виджетах. Также можно заметить, что в случае композиции родительский виджет зависит от дочернего, тогда как в
  случае наследования --- наоборот.

Таким образом *наследование* --- связь на уровне классов (типов) и не имеет никакого значения в рантайме, тогда как
*композиционная* связь существует на уровне экземпляров виджетов и обуславливает иерархию виджетов в рантайме.


Иерархия виджетов
=================

В каждый момент времени все виджеты, присутствующие на странице, составляют древовидную иерархию. Существует *корневой*
виджет --- это виджет, на который указывает текущий роут (URL). Все виджеты, которые присутствуют в его шаблоне,
являются непосредственно его дочерними виджетами и т.д.

Когда происходит смена текущего экрана (роута), в большинстве случаев происходит перестройка дерева виджетов, корневой
виджет изменяется, он и часть его дочерних виджетов уничтожаются, а часть становится дочками нового корневого виджета.

.. code-block:: html
  :linenos:
  :caption: bundles/example/widgets/helloWorldPage/helloWorldPage.html

  {#extend type="//BaseLayout" title="Hello World!!!"}
    {#widget type="//CurrentTime"/}
  {/extend}

В данном примере экземпляры виджетов и ``BaseLayout`` и ``CurrentTime`` будут является дочками виджета
``HelloWorldPage``. Они будут даже перечислены в специальном свойстве ``children`` в экземпляре ``HelloWorldPage``.

Вероятно, кого-то смутило, что виджет ``BaseLayout`` в примере назван *дочерним* несмотря на использование ``#extend``.
Важно понимать, что с помощью плагина ``#extend`` формируется ещё одна *иерархия лейаутов*, которая играет ключевую
роль в оптимальном переключении страниц с сохранением неизменных элементов навигации и базовой html-разметки. В этой
иерархии "корневым" всегда является виджет, который вдадеет тегом ``html``.

.. warning::

  Важно! Не путайте иерархию лейаутов, формируемую с помощью ``#extend`` и основную рантайм-иерархию виджетов по
  принципу происхождения с отношениями родитель-дочка.

Родительский виджет имеет возможность:

* обратиться непосредственно к экземпляру дочернего виджета и вызывать у него публичный API-метод, специально для
  этого предназначенный (по-умолчанию, у виджета нет никаких публичных методов),
* вызывать метод ``setParams`` у дочернего виджета, поспольку параметры являются публичным API виджета,
* подписаться на событие, которое бросает дочерний виджет,
* создать новый или уничтожить дочерний виджет посредством behaviour-класса.

Всё это касается только непосредственных дочек, родительский виджет не должен обращаться к дочкам дочек, так же как и
к переменным контекста дочерних виджетов, т.к. это грубо нарушает инкапсуляцию.

При этом виджет не должен делать никаких предположений о том, какой виджет является его родительским, поскольку это
может быть любой другой виджет. Единственный способ связи с родительским виджетом --- бросить событие, родительский
виджет может среагировать на него, а может и нет.

``BaseLayout`` в нашем примере ничего "не знает" ни о виджете ``HelloWorldPage``, ни о ``CurrentTime``, который будет
вставлен в его плейсхолдер.

.. _widget-life-cycle:

Жизненный цикл виджета
======================

1. Создание экземпляра виджета
------------------------------

Экземпляр корневого виджета создаётся роутером, все остальные виджеты создаются рекурсивно либо в процессе рендеринга
шаблона родительского виджета, либо динамически в behaviour-классе родительского виджета.

При создании виджета происходит инициализация его состояния по-умолчанию из свойства ``@initialCtx``, присваивается
уникальный идентификатор (``@ctx.id``), происходит его регистрация в родительском виджете, а также внедрение
сервисов-зависимостей из контейнера сервисов.

2. Формирование первоначального состояния
-----------------------------------------

Далее, прежде чем отрендерить шаблон, происходит формирование перевоначального состояния (контекста) виджета.

Обработка параметров
^^^^^^^^^^^^^^^^^^^^

Происходит вызов обработчиков входящих параметров виджета (для тех параметров, которые были явно переданы).
Функции-обработчики тем или иным образом изменяют переменные контекста (``@ctx``) виджета.

onShow
^^^^^^

После того, как отработали все обработчики параметров, исполняется специальная callback-метод ``onShow`` (если он
объявлен). Его удобно использовать для выставления каких-либо начальных значений переменных контекста, если они не
были заданы с помощью входящих параметров или не могут быть заданы простым скалярным выражением в ``@initialCtx``.


3. Рендеринг шаблона
--------------------

Далее происходит рендеринг шаблона виджета с учётом сформированного состояния (``@ctx``). Рендеринг производится
шаблонизатором Dust.js и на выходе получается html-строка с конечной разметкой виджета. Когда виджет добавляется в
шаблон другого виджета, он дополнительно оборачивается специальным корневым элементом.

Этот и все вышеописанные этапы могут происходить как на сервере (Node.js), так и в браузере. Все последующие этапы
происходят только в браузере.


4. "Оживление" (инициализация в браузере)
-----------------------------------------

Далее html-разметка виджета превращается в DOM-дерево в браузере. Если страница рендерилась на сервере, то это
происходит в процессе её начального отображения в браузере, а если виджет изначально создавался в браузере, то CordJS
сначала создаёт DOM-элемент виджета, отвязанный от DOM-дерева документа (т.е. он не отображается).

Далее происходит процесс "оживления":

* Создание и инициализация экземпляра behaviour-класса (если есть),
* Навешивание обработчиков DOM-событий,
* Ожидание загрузки CSS-зависимостей виджета.

CordJS (за редким исключением) старается не показывать пользователю "неживой" интерфейс, который не способен
реагировать на его действия. Поэтому добавление корневого элемента виджета в DOM-дерево документа происходит только
после его "оживления".

markShown
^^^^^^^^^

Разработчику часто необходимо выполнить какое-либо действие именно в тот момент, когда виджет будет "показан"
пользователю.

Сразу после оживления виджета и добавление его в DOM-дерево документа вызывется метод ``markShown()``, который
переводит виджет в состояние "показан" (shown) и вызывает соответствующие callback-обработчики.

В случае, если виджет был отрендерен на стороне сервера, ``markShown`` вызывается сразу после его оживления,
поскольку он уже по факту "показан" пользователю, когда браузер загрузил стартовую страницу.


5. Динамическое изменение состояния
-----------------------------------

После того, как виджет показан пользователю, в какой-то момент его состояние может измениться. Это может быть вызвано
пользовательским DOM-событием, изменением входящего параметра и т.п. Важно, что вызовется какая-либо
callback-функция, которая изменит ``@ctx``. Если у виджета у виджета объявлен behaviour-класс, то в нём может быть
прописано два способа реагирования на изменение конкретной переменной контекста:

* **Полный ре-рендеринг виджета.** В этом случае экземпляр behaviour-класса виджета уничтожается, уничтожаются все
  дочерние виджеты, заново повторяются этапы 3 и 4 (см. выше) жизненного цикла, старый DOM-элемент виджета заменяется
  на полностью новый.

* **Ручная DOM-манипуляция.** В этом случае программист вручную изменяет DOM-дерево виджета, чтобы привести его в
  соответствие новому состоянию.

Если у виджета есть дочерние виджеты и их параметры "привязаны" к состоянию виджета, то дочерние виджеты
автоматически получат изменения в виде новых параметров и отреагируют соответствующим образом.


6. Уничтожение
--------------

Виджет может быть уничтожен по следующим причинам:

* Роутер изменяет корневой виджет и старый корневой виджет уже не нужен.
* Уничтожается родительский виджет.
* Родительский виджет заново рендерит свой шаблон (re-render).
* Разработчик вручную удаляет дочерний виджет из родительского (зачастую, такой дочерний виджет был также создан
  вручную).

.. warning::

  При ручном удалении виджета разработчик сам должен позаботиться об удалении соответствующего DOM-элемента.


Репозиторий виджетов (WidgetRepo)
=================================

Для управления виджетами в CordJS существует специальный сервис - ``WidgetRepo``. Он отвечает за корректное создание
и удаление виджетов, содержит список всех активных виджетов, хранит ссылку на корневой виджет, перестраивает иерархию
виджетов при измененении корневого виджета, отвечает за корректную передачу состояния с сервера и инициализацию
виджетов в браузере.

Это по большей части внутренний сервис в подавляющем большинстве случаев к нему обращаться не нужно.
