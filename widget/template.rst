**************
Шаблон виджета
**************

Шаблон виджета определяет, что будет собой представлять DOM-дерево виджета после рендеринга. Файл шаблона должен
располагаться в папке виджета и называться так же, как и папка, но с расширением ``.html``.

В качестве шаблонизатора в CordJS используется `Dust.js <http://www.dustjs.com/>`_. Выбор именно этой библиотеки
обусловнен следующими факторами:

* высокая скорость,
* сохранение обычно html-разметки, хороший баланс в плане разделения логики и разметки,
* возможность асинхронного рендеринга (т.е. разные части одного шаблона могут рендериться "параллельно"),
* возможность легко встраивать собственные плагины.

С синтаксисом Dust.js можно легко ознакомиться в `его документации <http://www.dustjs.com/guides/getting-started/>`_.
Этот раздел посвящён расширениям (плагинам) CordJS, которые позволяют удобно собирать пользовательские интерфейсы из
виджетов.

Использование dust-плагина в шаблоне выглядит так:

.. code-block:: html
  :linenos:

  {#somePlugin param1="123" param2=contextVar}
    Тело плагина (любая разметка)
    <div>{anotherCtxVar}</div>
  {/somePlugin}

  {#withoutBodyPlugin param1="123"/}

В качестве значения параметра в плагин может передаваться либо константа (в кавычках), либо значение переменной
контекста. Рендеринг того, что находится в теле плагина, управляется плагином.


Dust-плагины CordJS для поддержки рендеринга виджетов
=====================================================

.. _#placeholder:

#placeholder
------------

**Плейсхолдер** резервирует специальное место в разметке виджета, в которое могут вставлять свой контент виджеты,
*расширяющие* данный виджет (посредством плагинов ``#extend`` или ``#widget``, см. ниже). ``#placeholder`` ---
ключевой плагин, позволяющий реализовать концепцию лейаутов, описанной в :ref:`Quick Start Guide <quickstart-layout>`.

С точки зрения конечной разметки, плейсхолдер представляется собой html-тег ``div`` с автоматически сгенерированным
атрибутом ``id``, внутри которого может размещаться контент родительских виджетов.

Поддерживаемые параметры:

* ``name`` --- название плейсхолдера. Значение по умолчанию --- ``default``. В одном виджете может быть объявлено
  несколько плейсхолдеров. В этом случае только один из них может иметь значение по умолчанию, а остальным должны
  быть присвоены уникальные имена. На них будут ссылаться вставляемые в плейсхолдер блоки контента посредством
  параметра ``placeholder`` (см. :ref:`#widget`, :ref:`#inline`). В большинстве случаев плейсхолдер у виджета
  максимум один и следует использовать название по умолчанию.

* ``placeholder`` --- название плейсхолдера, в который следует вставить этот плейсхолдер. Применим только в случаях,
  когда плейсхолдер вставляется в плейсхолдер другого виджета (т.е. в шаблоне он находится в теле другого плагина
  ``#widget`` или ``#extend``) и таким образом "проксирует" его дальше. Использовать этот параметр не обязательно, если
  пробрасывается плейсхолдер по умолчанию (с именем ``default``).

* ``bypass`` --- синтаксический сахар, применимый, когда плейсхолдер одного виджета "пробрасывается" дальше (выше) по
  уровню (по умолчанию, плейсхолдер может быть использован только непосредственным родительским виджетом) с
  сохранением имени. Использование параметра ``bypass="someName"`` равносильно использованию двух параметров
  ``placeholder="someName" name="someName"``. Нагляднее показано в примере ниже.

* ``class`` --- значение атрибута ``class`` для тега ``div``, представляющего плейсхолдер в DOM. Иногда удобно
  задавать какие-либо CSS-свойства для тега плейсхолдера, но этого следует избегать, поскольку эти свойства могут
  влиять на контент родительских виджетов, что концептуально неверно.

Плейсхолдер не принимает параметр-тело и всегда является самозакрывающимся.

.. code-block:: html
  :linenos:

  {#widget type="//SomeWidget"}
    {#placeholder bypass="header"/}
  {/widget}

  <div class="page">
    {#placeholder class="page-content"/}
  </div>

  <div class="footer">
    {#placeholder name="footer"/}
  </div>


.. _#widget:

#widget
-------

Плагин ``#widget`` позволяет вставить дочерний виджет в разметку текущего виджета. С точки зрения конечной
html-разметки на это место вставится автоматически сгенерированный корневой тег дочернего виджета, внутри которого
будет расположена разметка из шаблона дочернего виджета.

Плагин принимает следующие (собственные) параметры:

* ``type`` --- тип (класс) дочернего виджета, который может быть задан в одном из сделующих форматов:

  * ``./Child`` --- если дочерний виджет объявлен в папке текущего виджета.
  * ``//folder/Child`` --- относительное каконическое имя дочернего виджета в текущем :term:`бандле <бандл>` (текущего
    виджета).
  * ``anotherBundle//folder/Child`` --- относительное каконическое имя дочернего виджета в другом бандле, но в том же
    пространстве имён (относительно текущего виджета).
  * ``/ns/bundle//folder/Child`` --- абсолютное каноническое имя дочернего виджета.

* ``name`` --- уникальное имя (ключ) дочернего виджета в рамках текущего (родительского). Подробнее об использовании
  имени можно почитать в разделе :ref:`child-widgets`.

* ``class`` --- дополнительные CSS-классы (разделённые через пробел), которые следует добавить к корневому тегу
  дочернего виджета. Этим свойством не следует злоупотреблять. Свойства добавляемых таким образом классов должны
  влиять **только на позиционирование корневого тега дочернего виджета** в разметке родительского. Родительский
  виджет не имеет права вмешиваться в отображение приватного контента дочернего виджета.

* ``placeholder`` --- название плейсхолдера, в который следует вставить этот дочерний виджет. Применим только в
  случаях, когда виджет вставляется в качестве контента в плейсхолдер другого дочернего виджета (т.е. в шаблоне он
  находится в теле другого плагина ``#widget`` или ``#extend``). Использовать этот параметр не обязательно, если
  виджет вставляется в плейсхолдер по умолчанию (с именем ``default``).

* ``timeout`` --- количество миллисекунд, через которое рендеринг виджета считается "слишком долгим" и на его месте
  показыватеся заглушка. ``-1`` означает выключение таймаута (значение по умолчанию). ``0`` --- показать заглушку
  сразу. Подробнее об этом читайте в разделе про механизм таймаутов.

Обязательным параметром является только ``type``.

Параметры виджета
^^^^^^^^^^^^^^^^^

Все параметры с другими именами интерпретируются как параметры виджета и передаются ему в качестве параметров для
первичного рендеринга. Значения таких параметров, кроме статической константы и переменной контекста, могут принимать
значение в специальном формате: ``"^ctxVarName"`` (название переменной контекста в кавычках с "крышечкой" в начале).
Такая запись означает, что в качестве значения параметра будет передано значение переменной контекста с указанным
названием плюс...

* если значение переменной контекста на момент рендеринга *отложенное*, то дочерний виджет дождётся нормального
  значения и будет отрендерен в асинхронном режиме (не тормозя рендеринг остальных частей шаблона),

* произойдёт автоматическая подписка на изменения указанной переменной контекста, т.е. когда она будет изменена в
  будущем (после того, как виджет будет показан пользователю), то дочерний виджет автоматически получит сигнал с
  новым значением параметра и сможет соответствующим образом его обработать и отобразить себя по-новому.

Пример:

.. code-block:: html
  :linenos:
  :emphasize-lines: 3

  <div>
    {#widget type="//SomeWidget" name="child1" class="top-right" timeout="0"
             childParam="test" title="^childTitle" nonDeferredParam=anotherCtxVar /}
  </div>

.. warning::

  В параметрах виджетов почти всегда следует использовать формат "с крышечкой". Прямую ссылку следует использовать
  только тогда, когда значение переменной не может быть отложенным и никогда не изменяется в течение жизни виджета.

  Если в примере выше на момент рендеринга ``anotherCtxVar`` будет иметь отложенное значение, то оно не сможет быть
  обработано корректно --- ``nonDeferredParam`` получит в качестве значения строку ``:deferred``, что явно не
  соответсвует "ожиданиям".


Параметр-тело плагина ``#widget``
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Если в шаблоне вставляемого дочернего виджета есть :ref:`плейсхолдеры <#placeholder>`, то в теле плагина ``#widget``
можно указать контент, который нужно вставить в плейсхолдеры дочернего виджета. В качестве контента может выступать:

* Другой дочерний виджет посредством плагина ``#widget``.
* Произвольная разметка (подшаблон) посредством плагина ``#inline``.
* Плейсхолдер посредством плагина ``#placeholder``.

Количество вставляемых блоков контента не ограничено. Если в дочернем виджете несколько плейсхолдеров и вставка
происходит не в плейсхолдер по умолчанию, то нужный плейсхолдер указывается посредством параметра ``placeholder``
соответствующего плагина.

.. code-block:: html
  :linenos:
  :emphasize-lines: 7,10,12,14

  <div>
    Произвольная разметка
  </div>
  {#widget type="//SomeWidget" name="some"
           title="^childTitle"}

    {#inline placeholder="footer"}
      <div>Copyright 2012-2015</div>
    {/inline}
    {#widget type="//FeedbackForm" placeholder="footer"/}

    {#widget type="//Child" childParam="test"/} <!-- placeholder="default" -->

    {#placeholder bypass="header"/} <!-- placholder="header" name="header" -->
  {/widget}

.. note::

  В подобных случаях, когда посреди произвольной разметки вставляется виджет, внутрь плейсхолдеров которого
  вставляется контент, требуется указывать параметр ``name`` у дочернего виджета (``name="some"``), даже если этого
  не нужно с точки зрения родительского виджета. Это обусловлено особенностями внутренних алгоритмов компиляции таких
  шаблонов.


{:timeout}
^^^^^^^^^^

При использовании параметра ``timeout`` по умолчанию будет показана стандартная заглушка, которая может не
соответствовать стилю интерфейсов конкретного проекта. Dust.js позволяет указывать несколько "тел" для плагинов.
Используя эту возможность, виджет поддерживает дополнительное "тело" для разметки таймаут заглушки:

.. code-block:: html
  :linenos:
  :emphasize-lines: 2,3

  {#widget type="//SomeWidget" name="some" timeout="100"}
  {:timeout}
    <div class="timeout-stub"><div>
  {/widget}

В блоке ``:timeout`` может присутствовать только простая разметка, в которой не используются переменные контекста или
какие-либо CordJS-плагины. Это логично, поскольку на момент отображения этой заглушки виджет ещё "не готов".

.. _complex-widgets-limits:

Ограничения "сложносочинённых" дочерних виджетов (с телом)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Есть существенная разница между тем, как "внутри" рендерятся виджеты без "тела" (контент плейсхолдеров или
``:timeout``) и виджеты с "телом". Информация о контенте плейсхолдеров и таймаут-шаблонах записывается в специальные
структуры на этапе компиляции шаблона и является статической по сути. Для виджетов без "тела" таких статических
структур не создаётся и их рендеринг более "динамический".

Не вдаваясь глубого в подробности, следует знать о следующих ограничениях для виджетов с "телом":

* они не могут быть использованы внутри блоков-циклов,
* их можно использовать в условных блоках только при условии, что этот блок "сработает" (dustjs в него зайдёт) при
  значенях переменных контекста по умолчанию (во время компиляции исползуются именно они).


#extend
-------

Плагин ``#extend`` очень похож на ``#widget`` --- он по сути вставляет дочерний виджет в шаблон текущего виджета ---
однако его использование имеет особенные свойства:

* ``#extend`` должен быть первым "выражением" в шаблоне, никакой разментки вне него быть не может, всё только внутри.
* ``#extend`` всегда с "телом", но использование параметра ``name`` не обязательно.
* ``#extend`` может быть исползован в шаблоне только один раз, все остальные дочерние виджеты вставляются через
  ``#widget``.
* Виджет, использующий в своём шаблоне ``#extend`` не имеет своего корневого элемента, поскольку вся его собственная
  разменка вставлена в плейсхолдеры виджета, указанного в ``#extend``.
* ``#extend`` не поддерживает параметр ``timeout`` и блок ``{:timeout}``.

Главное предназначение ``#extend`` --- формирование дерева лейаутов с вершиной в базовом леайут-виджете
(``BaseLayout``), который содержит теги html/head/body. С помощью этого дерева леайтов в CordJS осуществляется
плавный роутинг на стороне браузера без перезагрузки страницы и перерисовки общих навигационных частей.

Типичный пример использования ``#extend``:

.. code-block:: html
  :linenos:
  :caption: public/bundles/hello/example/widgets/userCardPage/userCardPage.html
  :emphasize-lines: 1

  {#extend type="//MainLayout" title="User card"}
    {#widget type="//UserCard" userId="^userId"/}
  {/extend}

.. code-block:: html
  :linenos:
  :caption: public/bundles/hello/example/widgets/mainLayout/mainLayout.html
  :emphasize-lines: 1

  {#extend type="//BaseLayout" title="^title"}
    {#widget type="//Header"/}
    {#placeholder/}
    {#inline class="footer"}
      &copy; 2012-2015
    {/inline}
  {/extend}


#deferred
---------

Плагин ``#deferred`` позволяет корректно рендерить шаблон с отложенными переменными контекста, даже если они
используются в шаблоне вне специального формата параметров виджета "с крышечкой". Дальше будет понятней...

Представим виджет со следующим шаблоном:

.. code-block:: html
  :linenos:
  :emphasize-lines: 2

  <div>
    {contentString}
  </div>

Если значение переменной контекста ``contentString`` получается асинхронно и на момент рендеринга значение было
*отложенным*, то пользователь увидит строку ``:deferred`` вместо полученной строки. Это связано с тем, что
шаблонизатор "не поймёт", что значение отложено и нужно подождать. К сожалению, Dust.js не даёт возможности
специальным образом обрабатывать вставки переменных из контекста. В такой ситуации на помощь приходит плагин
``#deferred``:

.. code-block:: html
  :linenos:
  :emphasize-lines: 2-4

  <div>
  {#deferred params="contentString"}
    {contentString}
  {/deferred}
  </div>

Плагин принимает единственным параметр ``params`` --- список названий переменных контекста, перечисленных через
запятую, которые нужно проверить на отложенное значение. Тело плагина --- подшаблон, который будет отрендерен
асинхронно, когда все перечисленные переменные будут готовы.

Тело-подшаблон ``#deferred`` обрабатывается статически на этапе компиляции, поэтому на него действуют те же
ограничения, что и на ``#widget`` с телом: :ref:`complex-widgets-limits`.


.. _#inline:

#inline
-------

Плагин ``#inline`` предназначен для вставки произвольного одноразового (инлайн) контента в плейсхолдер дочернего
виджета. В отличие от других плагинов, он может быть использован только в "теле" ``#widget`` или ``#extend``. С точки
зрения конечной html-разметки внутрь корневого элемента плейсхолдера вставится автоматически сформированный корневой
элемент inline-блока (по умолчанию ``div``), внутри которого будет результат рендеринга inline-подшаблона.

Поддерживаемые параметры:

* ``name`` --- уникальное название inline-блока в рамках виджета. По умолчанию формируется автоматически. Вручную его
  следует указывать только при необходимости использования метода ``renderInline()`` для ручного управления
  перерисовкой inline-блока.
* ``tag`` --- html-тег корневого элемента inline-блока. По умолчанию ``div``.
* ``class`` --- значение атрибута ``class`` для корневого тега, представляющего inline-блок в DOM.
* ``placeholder`` --- название плейсхолдера дочернего виджета, в который следует вставить этот inline-блок.
  Использовать этот параметр не обязательно, если inline-блок вставляется в плейсхолдер по умолчанию (с именем
  ``default``).

Пример:

.. code-block:: html
  :linenos:
  :emphasize-lines: 3

  {#extend type="//MainLayout"}

    {#inline tag="header" placeholder="header" class="header-content"}
      <div>Main menu</div>
      {#widget type="//UserMenu"/}
      <div class="toolbar">
        {#placeholder name="toolbar"/}
      </div>
    {/inline}

  {/extend}


Dust-плагины для поддержки серверного рендеринга
================================================

Есть два системных плагина, которые необходимо использовать в шаблоне базового виджета (виджет, который владеет
тегами html/head/body), чтобы вся инфраструктура фреймворка работала корректно.

#css
----

Плагин ``#css`` вставляет список тегов ``link`` со ссылками на CSS-файлы виджетов, которые участвовали в формировании
конечной html-страницы при серверном рендеринге. Его использование необходимо, чтобы при отображении страницы после
загрузки с сервера она сразу выглядела "правильно" с нужными стилями. Плагин не принимает никаких параметров. Плагин
следует вставить в любом месте внутри тега ``head``:

.. code-block:: html
  :linenos:
  :emphasize-lines: 3,8
  :caption: public/bundles/hello/example/widgets/baseLayout/baseLayout.html

  <!doctype html>
    <head>
      {#css/}
    </head>

    <body>
      {#placeholder/}
      {#widgetInitializer/}
    </body>
  </html>

.. _#widgetInitializer:

#widgetInitializer
------------------

Плагин ``#widgetInitializer`` вставляет в html-код страницы, сгенерированной на сервере, следующее:

* Готовый конфигурационный JSON, собранный из конфигурационных файлов в папке ``conf``.
* Загрузку requirejs с инициализирующим скриптом, который запускает инфраструктуру CordJS.
* Код с инициализацией сериализованного состояния моделей и виджетов, которые участвовали в генерации страницы. Он
  "оживляет" виджеты, которые передались с сервера на браузер как часть html-страницы.

Плагин должен быть вставлен перед самым концом тега ``body`, чтобы скрипты не тормозили отображение страницы.


Вспомогательные dust-плагины
============================

.. _#url:

#url
----

Если в определении роута указано свойство ``routeId`` (уникальный идентификатор роута), то в шаблоне виджета есть
возможность сформировать URL по этому идентификатору и параметрам с помощью плагина ``#url``.

Плагин принимает один *собственный* параметр --- ``routeId`` --- строковой идентификатор роута. Все остальные
параметры передаются роутеру для формирования ссылки для указанного ``routeId``. Если параметр присутствует в шаблоне
роута (в формате ``:paramName``), то он переданное значение параметра будет подставлено в нужное место, все остальные
параметры попадут в query string (после ``?``).


#i18n
-----

Плагин ``#i18n`` позволяет получить доступ к системе переводов, используемой в проекте, и вставлять в шаблон
переводные строки. CordJS не реализует никакой системы переводов на разные языки, но плагин ``#i18n`` регламентирует
простой API для встраивания любой своей.

Обязательный параметр для плагина только один --- ``text`` --- ключ, по которому нужно искать перевод (или перевод по
умолчанию). Зачастую этот ключ выводится в конечном итоге, если перевод на текущий язык не найден. Все остальные
параметры передаются системе переводов "как есть" и не регламентированы --- это может быть пространство имён
перевода, число (для численнных словоформ), падеж, род, просто параметры для подстановки по шаблону и т.д --- всё
зависит от возможностей системы переводов.

В контексте виджета необходимо объявить функцию ``i18nHelper``, которая принимает на вход два аргумента: строковой
ключ и объект с параметрами, и возвращает строку с конечным переводом. Зачастую, эта функция встраивается в контекст
в методе ``onShow``:

.. code-block:: coffee
  :linenos:

  class SomeWidget extends Widget

    @inject: ['translator']  # translator - некий сервис, реализующий систему переводов

    onShow: ->
      @ctx.i18nHelper = (text, params) =>
        @translator.translate(text, params)
      # или, например, так
      @translator.injectHelper(@ctx)



Использование булевых констант в шаблоне
========================================

У Dust.js есть небольшой недочёт: в шаблоне невозможно передать булеву константу в качестве параметра в какой-нибудь
плагин. Например:

.. code-block:: html
  :linenos:

  {#widget type="//SomeWidget" showToolbar="true"/}

Параметр ``showToolbar`` получит строковое ``"true"`` вместо булева.

Для обхода этого неудобства в контексте виджета всегда присутствуют два ключа --- ``true`` и ``false`` --- и их можно
использовать следующим образом (обратите внимание на отсутствие кавычек):

.. code-block:: html
  :linenos:

  {#widget type="//SomeWidget" showToolbar=true disableIcons=false /}
