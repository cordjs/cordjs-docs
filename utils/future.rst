******************************************
Future --- собственная реализация промисов
******************************************

Исторически сложилось, что в CordJS используется собственная реализация промисов (Promise). Описание самой концепции
промисов выходит за рамки этой документации, об этом можно прочитать много где ещё. В данной главе концептуальной
роли промисов в инфраструктуре CordJS и особенностей реализации.


Отказ от колбеков в пользу промисов
===================================

В процессе развития фреймворка способы работы с асинхронными вычислениями менялись. Вначале это были классические
callback-функции, принятые в Node.js. Затем постепенно пришло понимание ущербности работы с колбеками (есть даже
такой устоявшийся термин --- *callback hell*), и практически все асинхронные вычисления были представлены в виде
абстракции промисов, т.к. с ними гораздо удобнее работать.

Любая функция, выполняющая асинхронные вычисления должна возвращать результат в виде промиса.


Особенности реализации библиотеки Future
========================================

Собственная библиотека промисов в CordJS называется Future (как в Scala) и доступна по пути ``cord!utils/Future``.
Метод ``then`` у экземпляра промиса работает так, как прописано в стандарте js-промисов, однако процесс создания
промиса отличается.

Future обладает довольно богатыми возможностями для дебага.

В последнее время принято решение делать API Future максимально совместимым с API одной из лучших реализаций промисов
`Bluebird <https://github.com/petkaantonov/bluebird>`_, чтобы впоследствии, возможно, перейти на эту библиотеку и
отказаться от собственной реализации. Вот список совместимых методов:

* `bind <https://github.com/petkaantonov/bluebird/blob/master/API.md#binddynamic-thisarg---promise>`_ --- даёт
  возможность биндить callback-функции промиса и последующей цепочки к нужному объекту без использования жирной
  стрелки.
* `finally <https://github.com/petkaantonov/bluebird/blob/master/API.md#finallyfunction-handler---promise>`_ ---
  callback-функция отрабатывает всегда, независимо от результата промиса. В отличие от реализации в Bluebird, во
  Future в колбек передаётся два аргумента в Node.js-стиле --- ошибка и результат --- это очень удобно, когда
  обработку результата нужно произвести какой-либо node-функцией.
* `then
  <https://github.com/petkaantonov/bluebird/blob/master/API.md#thenfunction-fulfilledhandler--function-rejectedhandler----promise>`_
  --- классический ``then`` из стандарта.
* `catch <https://github.com/petkaantonov/bluebird/blob/master/API.md#catchfunction-handler---promise>`_ --- алиас к
  ``then`` с пустым первым аргументом.
* `spread
  <https://github.com/petkaantonov/bluebird/blob/master/API.md#spreadfunction-fulfilledhandler--function-rejectedhandler----promise>`_
  --- даёт возможность разбить результат-массив на несколько аргументов callback-функции. Удобно, когда нужно в
  промис запихнуть несколько (фиксированное количество) значений.
* `Promise.all <https://github.com/petkaantonov/bluebird/blob/master/API.md#all---promise>`_ --- сделать из массива
  промисов промис с массивом.
* `Promise.any <https://github.com/petkaantonov/bluebird/blob/master/API.md#any---promise>`_ --- получить первый
  успешный результат из массива промисов.
* `Promise.settle <https://github.com/petkaantonov/bluebird/blob/master/API.md#settle---promise>`_ --- получить из
  массива промисов промис с массивом результатов этих промисов, независимо от того, успешный результат или нет, с
  возможностью анализировать каждый из результатов на успешность.
* `isPending <https://github.com/petkaantonov/bluebird/blob/master/API.md#ispending---boolean>`_,
  `isRejected <https://github.com/petkaantonov/bluebird/blob/master/API.md#isrejected---boolean>`_,
  `value <https://github.com/petkaantonov/bluebird/blob/master/API.md#value---dynamic>`_,
  `reason <https://github.com/petkaantonov/bluebird/blob/master/API.md#reason---dynamic>`_ ---
  синхнонная проверка состояния промиса.
* `Promise.try
  <https://github.com/petkaantonov/bluebird/blob/master/API.md#promisetryfunction-fn--arraydynamicdynamic-arguments--dynamic-ctx----promise>`_
  --- преобразовать результат синхронной функции в промис с перехватом синхронных исключений и превращением их в reject.


Создание промисов
-----------------

В большинстве случаев конечному разработчику, пользующемуся стандартными средствами CordJS, не нужно пользоваться API
для ручного создания новых промисов, поскольку асинхронные функции и так возвращают промисы. Но иногда при работе с
внешними библиотеками это необходимо.

Самый стандартный способ создать новый промис, вызывать статический метод-конструктор ``Future.single()``, а затем в
нужный момент отрезолвить промис с помощью метода ``resolve``, или завершить его с ошибкой с помощью метода ``reject``:

.. code-block:: coffee
  :linenos:

  define [
    'cord!utils/Future'
  ], (Future) ->

    async100 = ->
      promise = Future.single('test promise')
      setTimeout ->
        if true
          promise.resolve(100)
        else
          promise.reject(new Error('some error message'))
      , 100
      promise

Метод ``single`` принимает на вход опциональный аргумент --- название промиса. Возможность давать названия промисам
--- особенность реализации, которая очень удобна для отладки. Поскольку в асинхронной среде нормальный стек-трейс
получить сложно, имя промиса может оказаться единственным простым способам "найти концы".

Метод ``resolve`` принимает на вход конечный результат асинхронных вычислений. Его получат callback-функции
``then``, которые обрабатывают положительный результат.

Метод ``reject`` принимает на вход исключение. Его получат на вход callback-функции ``then`` (или ``catch``), которые
обрабатывают ошибку.

Кроме статического метода ``single``, ``Future`` предоставляет несколько удобных конструкторов промисов для
специальных случаев:

* ``Future.resolved(value)`` --- создаёт промис с уже готовым результатом.
* ``Future.rejected(new Error)`` --- создаёт промис с ошибочным результатом.
* ``Future.timeout(millis)`` --- создаёт промис с пустым результатом, который резолвится через заданное количество
  миллисекунд.


``complete`` --- дополнение к ``resolve`` и ``reject``
------------------------------------------------------

Метод принимает на вход два аргумента в node-стиле: ошибку и успешный результат. Если передана ошибка, то промис
завершается с ошибкой, иначе --- успешно. Удобно использовать с node-функциями.


``when``, ``link`` --- связать результат одного промиса с результатом другого
-----------------------------------------------------------------------------

``when`` принимает на вход промис. Когда этот промис завершится с каким-либо результатом, то с таким же результатом
завершится и промис, у которого вызван метод ``when``. Ошибочный результат тоже пробрасывается.

``link`` делает ровно противоположное. Принимает на вход промис и завершает его результатом своего промиса (у
которого вызван метод ``link``).


``catchIf`` --- условный ``catch``
----------------------------------

Принимает на вход 2 аргумента:

* Условие перехвата ошибки. Может быть одним из двух:

  * *Класс ошибки* (должен быть наследником ``Error``). Перехват произойдёт, если класс пришедшей ошибки
    ``instanceOf`` указанный класс.
  * *Функция-предикат*, котороый на вход подаётся пришедшая ошибка, а на выходе ``true`` или ``false``. Перехват
    произойдёт, если предикат вернёт ``true``.

* *Функция-обработчик ошибки* (не обязательно) --- вызывается, если условие из первого аргумента сработало и работает
  полностью аналогично коллбеку ``catch``.

Если условие из первого аргумента не выполняется, то возвращается промис с вошедшей ошибкой. Если условие выполнено,
но функция-обработчик не указана, то возвращается промис с пустым положительным результатом.


``isResolved`` --- нестандартное имя для ``isFulfilled``
--------------------------------------------------------

См. `isFulfilled <https://github.com/petkaantonov/bluebird/blob/master/API.md#isfulfilled---boolean>`_ в Bluebird.


``clear`` --- отмена промиса
----------------------------

Метод удаляет все callback-функции, ожидающие завершения промиса и переводит его в специальный статус, не позволяющий
его использовать в дальнейшем.

Отмена (cancellation) промиса --- довольно опасная и противоречивая вещь, поэтому следует использовать этот метод с
крайней осторожностью.


``Future.call`` --- вызвать node-style функцию и завернуть результат в промис
-----------------------------------------------------------------------------

Первый аргумент --- одно из двух:

* Ссылка на функцию, последний аргумент которой --- callback-функция в стиле Node.js, т.е. принимающая на вход 2
  аргумента --- ошибку и положительный результат.

* Если функция должна быть вызвана в контексте какого-либо объекта, то следует передать массив из двух элементов:

  1. Объект-контекст.
  2. Строковое название метода этого объекта с результатом-коллбеком в стиле Node.js.

Последующие аргументы --- аргументы, которые нужно передать вызываемой функции, за исключением последнего
callback-аргумента-результата.

Пример:

.. code-block:: coffee
  :linenos:

  Future.call(fs.writeFile, 'test.txt', 'hello world').then ->
    console.log 'test.txt is saved'
  .catch (err) ->
    console.error 'failed to save test.txt', err

  Future.call([stylus(stylusString), 'render']).then (cssString) ->
    console.log 'stylus rendering result', cssString


``Future.require`` --- завернуть AMD модуль(и) в промис
-------------------------------------------------------

Принимает на вход перечисление названий модулей или массив с названиями модулей в качестве первого аргумента.

Если на входе перечислен только один модуль, то результатом является этот модуль, завёрнутый в промис. Если
несколько, то массив модулей, завёрнутый в промис:

.. code-block:: coffee
  :linenos:

  Future.require('jquery').then ($) -> $('#content')

  Future.require('jquery', 'cord!utils/DomHelper').spread ($, DomHelper) -> # код

  Future.require(['jquery', 'cord!utils/DomHelper']).spread ($, DomHelper) -> # код


Устаревшее API
==============

Поскольку библиотека Future долго эволюционировала, в старом коде можно повстречать использование API, которое не
следует копировать. К этим методам относятся ``fork``, ``lock``, ``done`` и ``fail``.

``fork`` и ``lock`` служили для реализации концепции множественного результата промиса с использованием внутреннего
счётчика. Сейчас эта концепция считается ущербной и устаревшей.

``done`` и ``fail`` являются аналогами методов ``then`` и ``catch``, но не умеют по умному перехватывать исключения и
в качестве результата возвращают исходный промис, а не новый. Их не следует использовать в новом коде, а старый код
должен быть постепенное переделан.

Также не следует использовать конструктор Future напрямую. Вместо этого следует использовать ``Future.single`` или
другой метод создания нового промиса.


Средства отладки
================

Библиотека Future реализует два основных механизма отладки:

* Автоматическое уведомление о промисах, которые остались незавершёнными (ни положительным результатом, ни ошибкой)
  после определённого таймаута.
* Автоматическое уведомление о промисах с ошибочным результатом, у которых нет ни одного ``catch``-обработчика.


"Future timed out"
------------------

Поведением уведомлений о таймаутах управляют следующие глобальные настройки:

* ``debug.future.timeout`` --- через сколько миллисекунд после создания промиса сообщать о таймауте. Если 0, то не
  сообщать.
* ``debug.future.trackInternalTimeouts`` --- сообщать о таймаутах производных промисов, которые получены с помощью
  методов ``then``, ``catch``, ``finally``, ``spread``, ``when``, ``link``. Идея в том, чтобы не засорять консоль
  слишком большим количеством сообщений об ошибках. По умолчанию ``false``, т.е. будет показываться сообщение о
  таймауте только самого исходного промиса.


``withoutTimetout`` --- выключить сообщение о таймауте для этого промиса
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Если разработчик знает, что данный промис может никогда не завершится и это нормально, то можно вызвать метод
``withoutTimeout()``, который выключит трекинг конкретно для этого промиса. Метод не принимает аргументов и
возвращает исходный промис (для удобства построения цепочек вызовов).


"Unhandled rejection detected"
------------------------------

Поведением уведомлений о необработанных ошибках управляют следующие глобальные настройки:

* ``debug.future.trackUnhandled.enable`` --- включить трекинг необработанных ошибок промисов.
* ``debug.future.trackUnhandled.soft`` --- если ``true``, то не считать промис с фактически успешным результатом,
  необработанным. Если ``false``, то сообщение об остутствии обработчика ошибок будет выводиться даже для промисов с
  успешным резултатом, если у них не было ни одного обработчика ошибки.
* ``debug.future.trackUnhandled.interval`` --- внутренний интервал сканирования промисов на предмет необработанности
  ошибок или таймаутов (в миллисекундах). Рекомендуется выставлять значение не большее, чем минимальный таймаут.
* ``debug.future.trackUnhandled.timeout`` --- через сколько миллисекунд после создания промиса сообщать о наличии
  необработанной ошибки.


``failOk``, ``failAloud`` --- грамотное "закрытие" ошибок
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

В идеале при грамотной безошибочной разработке трекер необработанных ошибок не должен срабатывать никогда, поскольку
все ошибки должны тем или иным способом явно обрабатываться. Есть две крайние ситации:

* Цепочка асинхронных вызовов закончена, и если она завершилась с ошибкой, то сделать ничего нельзя, нужно просто
  вывести это в лог. Для таких случаев предназначен метод ``failAloud``, который выдаёт в лог сообщение об ошибке
  немедленно, не дожидаясь трекера. Метод принимает на вход опциональное сообщение, которое будет добавлено к
  исходной ошибке, и возвращает исходный промис для удобства огранизации цепочек вызовов.

* Цепочка асинхронных вызовов закончена, разработчик знает, что она может завершиться ошибкой, но это не страшно,
  поскольку эта ошибка обрабатывается где-то в другой ветке или вообще не стоит того, чтобы её логгировать. В этом
  случае можно вызывать метод ``failOk``, который добавит промису пустой обработчик ошибки и подавит работу трекера
  необработанных ошибок.


Длинный стек-трейс
------------------

Оба средства отладки выводят стек-трейс: для сообщения о таймауте --- это стектрейс к точке создания промиса, для
необработанной ошибки --- стектрейс ошибки. Однако, в асинхронной среде обычновенный стек-трейс обычно бесполезен.
Средства отладки Future умеют показывать так называемыый "длинный стек-трейс", который показывает полезную информацию
о последовательности вызовов сквозь асинхронные вызовы.

Сбор длинного стек-трейса --- довольно ресурсоёмкая задача, поэтому эту функциональность следует включать только в
разработческой среде и выключать в продакшн. Этим управляют следующие глобальные настройки:

* ``debug.future.longStackTrace.enable`` --- включить длинные стек-трейсы.
* ``debug.future.longStackTrace.appendPromiseName`` --- добавить название промиса напротив каждой строки длинного
  стек-трейса. Поскольку длинный стек собирается из цепочек промисов, то там будут разные имена, которые помогут
  понять что происходило.
* ``debug.future.longStackTrace.logOriginStack`` --- если ``true``, то после длинного стек-трейса показать простой
  стек-трейс происхождения промиса.


``rename``, ``nameSuffix`` --- модификация имени промиса
--------------------------------------------------------

Все средства отладки Future выводят название промиса, если оно есть. Название промиса может задаваться во время его
конструирования (например, во ``Future.single``), но это не всегда возможно и удобно. Для управления названием
промиса есть несколько методов, которые принимают на вход строку и возвращают исходный промис:

* ``rename`` --- заменяет имя промиса на переданное.
* ``nameSuffix`` --- добавляет к текущему имени промиса переданный суффикс, заключённый в квадратные скобки.


Особенности реализации
======================

Все колбек-функции, которые навешиваются на промисы, выполняются гарантировано асинхронно, независимо от текущего
состояния промиса. Для обеспечения максимально быстрой реализации асинхронности используется библиотека `asap
<https://github.com/kriskowal/asap>`_.
