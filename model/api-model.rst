**********
API модели
**********

Конструирование модели
======================

Модели, соответствующие данным, уже существующим на сервере, конструируются автоматически во время синхронизации
коллекции с сервером. Вручную нужно конструировать только новые сущности, которые должны быть добавлены на сервере.
Для этого можно воспользоваться одним из способов:

* **Конструктор класса модели* --- просто взять класс нужной модели (или просто ``Model``, если нет специального
  класса) и вызвать его конструктор без аргументов, а затем с помощью метода ``set`` добавить полей со значениями.

  .. code-block:: coffee
    :linenos:

    user = new Model
    user.set
      login: 'foo'
      email: 'foo@example.com'
    userRepo.save(user)  # user.save() вызвать нельзя, поскольку нет привязки к коллекции

* :ref:`Метод репозитория buildNewModel <model-repo-api-buildNewModel>` --- отличается от конструктора только тем,
  что сразу внедряед в модель методы-действия из настройки репозитория ``actions``. Кроме того, при таком подходе не
  нужно заботиться о правильном классе модели, репозиторий сам его знает:

  .. code-block:: coffee
    :linenos:

    userRepo.buildNewModel
      login: 'foo'
      email: 'foo@example.com'
    userRepo.save(user)  # user.save() вызвать нельзя, поскольку нет привязки к коллекции


``setCollection`` --- привязка новой модели к коллекции
-------------------------------------------------------

Модель сама по себе является простым набором полей, которые можно читать и изменять. Она не "знает", как себя
сохранять, удалять и т.п. Все подобные операции в зоне ответственности репозитория, поэтому, чтобы работало API модели,
которое осуществляет операции с бекендом, необходимо привязать модель к соответствующей коллекции, которая, в свою
очередь, связана с репозиторием.

Один из способов это сделать --- воспользоваться методом коллекции :ref:`addModel <models-api-addModel>`. У модели
есть более низкоуровневый метод ``setCollection``, который принимает на вход коллекцию и просто привязывает модель к
ней.

.. warning::

  Метод ``setCollection``, в отличие от ``Collection::addModel``, не добавляет модель в указанную коллекцию, а просто
  записывает коллекцию в специальное поле модели, что делает доступным API модели, завязанное на коллекцию и
  репозиторий: ``save``, ``delete``, ``on``, ``setAloud`` и вызовы дополнительных внедрённых действий.


Чтение полей
============

Доступ к полям модели, так же как и :ref:`в контексте <context-read>`, происходит посредством прямого доступа к полям
экземпляра модели:

.. code-block:: coffee
  :linenos:
  :emphasize-lines: 5

  model = userRepo.buildModel
    login: 'foo'
    email: 'foo@example.com'

  console.log "user's login is", model.login

При этом добавлять/изменять поля модели таким же прямым доступом нельзя, поскольку не сработают внутренние механизмы
регистрации изменений для последующей записи на сервер.


``toJSON`` --- получить чистый объект
-------------------------------------

Для получение простого объекта с полями модели можно воспользоваться методом ``toJSON``, который выгружает в
результат только поля модели, которые пришли в модель во время конструирования или были выставлены методом ``set``, и
пропускает все внутренние приватные поля модели.


Изменение полей
===============

Важно понимать, что во время непосредственного вызова методов изменения полей модели остальные экземпляры моделей с
тем же идентификатором и коллекции ничего не "узнают". Событие ``change`` бросается только после сохранения модели на
сервере (вызов ``save``). Только после этого происходит своего рода синхронизация данных между моделями с таким же
ID, и коллекциями, их содержащими. Но это поведение по умолчанию. Способом распространения изменений можно управлять.


``set`` --- добавить/изменить поле
----------------------------------

Добавление/изменение полей модели осуществляется посредством метода ``set``. Существует два варианта использования:

* На входе один аргумент-объект, у которого ключи --- названия полей модели, значения --- соответствующие новые
  значения. С помощью этого варианта можно добавить/изменить несколько полей за один вызов.
* На входе два аргумента: первый --- строковое название поля, второй --- новое значение поля. Так можно изменить
  значение только одного поля, но такой способ значительно удобнее, если само название поля является динамическим и
  лежит в другой переменной.

Примеры:

.. code-block:: coffee
  :linenos:

  user.set(login: 'foo')
  user.set
    login: 'foo'
    email: 'foo@example.com'

  user.set('login', 'foo')
  fieldName = 'login'
  user
    .set(fieldName, 'foo')
    .set(email: 'foo@example.com')

Метод ``set`` отрабатывает синхронно и возвращает саму модель (``this``), чтобы можно было писать цепочки вызовов.


``setAloud`` --- изменить поле с немедленным оповещением
--------------------------------------------------------

В некоторых ситуациях необходимо уведомить подсистему моделей об изменении поля ещё до того, как изменённое состояние
будет сохранено на сервере. Для этого можно использовать метод ``setAloud``, который принимает на вход два аргумента:

* *Строка* ``key`` --- название изменяемого поля модели.
* *Любой тип* ``val`` --- значение поля.

Событие ``change`` возникнет сразу после изменения значения поля и остальные экземпляры моделей с тем же ID смогут
локально обновить свои поля в соответствии с этим изменением.

Метод, так же как и ``set``, возвращает саму модель для удобства.


``emitLocalCalcChange`` --- оповестить об изменении произвольного поля
----------------------------------------------------------------------

Данный метод не изменяет непосредственно значение поля модели, несмотря на то, что указан в этом подразделе. Он
предназначен для оптимизации определённых ситуаций, когда после определённого изменения разработчик
знает, что бекенд изменит какое-либо зависимое поле.

Например, если в группу пользователей добавить нового пользователя, то, если у группы есть рассчитываемое поле
*количество пользователей*, то его значение увеличится на 1. Чтобы не запускать синхронизацию модели группы с
сервером (что может быть тяжёлой операцией и требует взаимодействия через медленную сеть), можно воспользоваться
методом ``emitLocalCalcChange``, чтобы сообщить подсистеме моделей о *локально-вычисленном изменении* поля модели.
Метод принимает на вход 2 аргумента:

* *Строка* ``path`` --- название (или, если это сложное поле связанной модели, путь через точки) поля модели,
  изменение которого мы хотим "предсказать".
* *Любой тип* ``val`` --- значение этого поля, которое мы "угадали".

Метод не изменяет непосредственно указанное поле у модели, у которой он вызван. Этого поля может и не быть в рамках
коллекции, к которой принадлежит эта модель. Вместо этого происходит оповещение всех коллекций о том, что изменилось
такое-то поле и модели с таким-то ID. Если поле есть в параметре ``fields`` коллекции и в ней содержится модель с
таким ID, то у этой модели обновляется значение указанного поля.


Взаимодействие с сервером
=========================

``save`` и ``delete``
---------------------

Методы ``save`` и ``delete`` не принимают аргументов и являются синтаксическим сахаром для вызова :ref:`аналогичных
методов репозитория <model-repo-api-save>` для данной модели.

.. _model-model-api-actions:

Внедрённые методы из настройки ``actions``
------------------------------------------

Если в :ref:`классе репозитория <model-repo-api-class>` указано свойство ``actions``, то при создании экземпляров
моделей в рамках этого репозитория в них внедряются методы, которые приводят к соответствующим API-запросам к бекенду.
Методы принимают на вход объект с параметрами запроса (если нужны) и возвращают результат API-вызова, завёрнутый в
промис. Пример:

.. code-block:: coffee
  :linenos:
  :emphasize-lines: 11

  class UserRepo extends ModelRepo

    restResource: 'user'

    actions:
      restorePassword: 'put'

  # где-то в виджете

  @userRepo.buildSingleModel(123).then (user) ->
    user.restorePassword(secretAnswer: 'baby')
  .then (response) ->
    console.log 'password restore token is', response.token
  .catch (err) ->
    console.error 'password restore failed!', err
