***************
API репозитория
***************

.. _model-repo-api-class:

Класс репозитория
=================

Исходный файл класса репозитория должен располагаться в папке ``models``. Класс репозитория, как правило, называется
с суффиксом ``Repo`` и так же называется исходный файл (с расширением ``.coffee``).

Ниже приведён пример класса со всеми возможными модификациями, которые описаны ниже:

.. code-block:: coffee
  :linenos:
  :caption: public/bundles/hello/example/models/UserRepo.coffee

  class UserRepo extends ModelRepo

    @inject: ['comet']

    restResource: 'user'
    model: UserModel

    actions:
      restorePassword: 'put'

    fieldTags:
      online: [':backendCalc']

    fieldCompareFunctions:
      online: (left, right) ->
        left != right

    predefinedCollections:
      onlineUsers:
        fields: ['login', 'device']
        filterParams:
          online: true

    init: ->
      if CORD_IS_BROWSER
        # какая-то инициализация, например, подписка на live-обновления с сервера

* ``@inject`` --- стандартное :ref:`описание статических зависимостей <di-inject>` для сервис-контейнера.

* ``restResource`` --- часть URL'а запросов к бекенд-сервису, определяющая REST-ресурс, соответствующий данному типу
  моделей. Это единственное обязательное поле при объявлении класса репозитория.

* ``model`` --- класс для моделей данного типа, если он отличается от стандартного ``cord!Model``. Должна указывается
  именно прямая ссылка на конструктор класса, а не строковой путь.

* ``actions`` --- позволяет автоматически добавлять методы-экшны к экземплярам моделей данного типа, которые будут
  делать запросы к урлам вида ``user/1234/restorePassword``. Ключи --- названия методов и завершающей части URL,
  значения --- HTTP-глагол, который должен использоваться для запроса: ``get``, ``put``, ``post`` или ``delete``. См.
  также :ref:`model-model-api-actions`.

* ``fieldTags`` --- даёт возможность подсказать классу, который формирует REST-запросы, что поле с таким названием
  нужно обрабатывать особым образом с помощью тегов. На момент написания документации поддерживается только тег
  ``:backendCalc``, который позволяет добавить соответствующее поле в параметр ``_calc``, а не в ``_fields``, в
  строке запроса к бекенду.

* ``fieldCompareFunctions`` --- даёт возможность объявить кастомную функцию сравнения на равенство для определённых
  полей. Эта функция будет использоваться при определении изменённости полей модели и необходимости бросать событие
  ``change``. Если специальной функции не объявлено, используется достаточно умный алгоритм сравнения по умолчанию.

* ``predefinedCollections`` --- позволяет объявить коллекции, которые будут созданы сразу при инициализации
  репозитория и могут быть использованы в любое время по имени. Ключ --- название коллекции, значение --- стандартные
  параметры коллекции (см. ниже).

* ``init`` --- метод, предназначенный для выполнения дополнительных инициализаций сразу после создания репозитория.
  Этот метод должен вызываться **явно** в функции-фабрике сервиса сразу после отработки ``injectServices``.


Доступ к репозиториям
=====================

Для работы с моделями в первую очередь нужно получить доступ к соответствующему репозиторию. Поскольку репозиторий
это обычный сервис в контейнере сервисов, то это можно сделать либо с помощью статического объявления зависимости в
``@inject``, если такое доступно, либо вызовом метода ``serviceContainer.getService('someRepo')``.

Прямой доступ к репозиторию не нужен в том случае, если нужная коллекция или модель зарегистрированы в виде
самостоятельных сервисов.


API работы с коллекциями
========================

Репозиторий чаще всего используется для работы с коллекциями: создания/удаления/доступа.


``createCollection`` --- создание динамической коллекции
--------------------------------------------------------

Метод принимает на вход объект с параметрами создаваемой коллекции и возвращет (синхронно) экземпляр зарегистрированной
коллекции. Пример:

.. code-block:: coffee
  :linenos:

  userCollection = userRepo.createCollection
    # name: 'allUsers'

    # fixed: false

    # models: [m1, m2, m3, m4, m5]
    # start: 16
    # end: 20
    # rawModelsData: [{ id:1, login: 'david' }]

    # id: 123
    # model: m1

    # accessPoint: 'example'

    fields: [
      'login'
      'name'
      'online'
      'avatar'
    ]

    filter:
      blocked: false

    # filterId: 'predefinedServerSideFilter'
    # filterParams: 'arbitraryParamsFotServerSideFilterWithFilterId'

    orderBy: 'name'
    pageSize: 50

    requestParams:
      additionalCustomParam: 123

    tags:
      'id.any':
        action: 'tagLiveUpdate'

Ниже описание параметров:

* ``name`` --- уникальное название коллекции в рамках своего репозитория. В большинстве случаев название не должно
  задаваться явно и формируется автоматически из остальных параметров. За счёт такого свойства, если в двух разных
  местах попробовать создать коллекции с одинаковыми параметрами, то будет создана только одна и повторно
  использована в обоих местах. Явное название в одновном предназначено для предопределённых в репозитории коллекций.

* ``fixed`` --- флаг, обозначающий, что данная коллекция управляется вручную разработчиком и не должна
  синхронизироваться с сервером. Вместе с этой опцией должна присутствовать опция ``models``.

* ``models`` --- массив экземпляров моделей, которыми "вручную" наполняется коллекция. Может использоваться как для
  ``fixed`` коллекций, так и для начального заполнения из какого-либо кеша обычных коллекций. Вместе с этим
  параметром могут использоваться параметры ``start`` и ``end`` для обозначения границ предзагруженных моделей
  поддержке постраничной загрузки.

* ``start`` --- индекс (с отсчётом от нуля) первой модели из списка ``models`` в общем потенциальном списке моделей
  коллекции с учётом постраничной подгрузки. Работает только в паре с параметром ``models``.

* ``end`` --- индекс (с отсчётом от нуля) последней модели из списка ``models`` в общем потенциальном списке моделей
  коллекции с учётом постраничной подгрузки. Работает только в паре с параметром ``models``.

* ``rawModelsData`` --- аналогично ``models``, но список не готовых моделей, а простых объектов с полями, которые
  предварительно превращаются в модели (полезно при десериализации).

* ``id`` --- идентификатор модели, для которой нужно создать single-model коллекцию. Такая коллекция сможет содержать
  только эту указанную модель. Для неё будут формироваться более оптимальные запросы к серверу.

* ``model`` --- то же, что и ``id``, но передаётся не идентификатор, а готовая модель.

* ``accessPoint`` --- дополнительный сектор пути в URL при ReST-запросе к серверу, который следует добавить к
  ``restResource`` (через ``/``) для запроса данной коллекции. Может понадобится, если какой-либо ресурс имеет какое-то
  особое поведение и набор полей для особой ситуации.

* ``fields`` --- список названий полей, которые должны иметь модели данной коллекции. В зависимости от реализации
  бекенда, можно указывать поля связанных моделей через точку, например ``participant.name``. В этом случае в
  конечной модели поле ``participant`` будет представлено объектом с полем ``name``.

* ``filter`` --- параметры простейшей фильрации по полям в формате ``<название параметра>: <нужное значение>``.
  Добавляются в URL запроса в виде аналогичных query-параметров.

* ``filterId`` --- если бекенд реализует какой-нибудь сложные фильтр, то у него должно быть название (идентификатор),
  которое можно указать в параметре ``filterId`` для использования этого фильтра.

* ``filterParams`` --- произвольные параметры для серверного фильтра, указанного в ``filterId``. Работает только в
  паре с ``filterId``.

* ``orderBy`` --- название или массив названий полей, по которым следует отсортировать список моделей в коллекции.
  Могут использоваться названия полей связанных моделей, как и в ``fields``. Если требуется сортировка в обратном
  порядке, следует использовать символ ``-`` (минус) перед названием поля, например ``-participant.name``.

* ``pageSize`` --- обозначает размер "страницы" (количество моделей) для подгрузки с помощью метода ``getPage``. Речь
  идёт именно о внутренней работе коллекции, а не об отображении списка пользователю. Если этот параметр не указан
  или равен нулю, то постраничная подгрузка не поддерживается.

* ``requestParams`` --- любые произвольные дополнительные параметры в виде объекта (ключ-значение), которые следует
  добавить в queryString URL'а запроса для получения данной коллекции.

* ``tags`` --- подсказки системе автоматического обновления коллекций о том, как себя вести при изменении тех или
  иных полей. Это позволяет сильно оптимизировать количество запросов обновления коллекций к серверу. Подробнее об
  этом в отдельном разделе.

.. warning::

  Коллекция, которую возвращает метод ``createCollection``, скорее всего, не наполнена моделями (не синхронизирована).
  Разработчик должен вызвать асинхронный метод ``sync`` или ``getPage`` у коллекции, прежде чем сможет манипулировать
  её содержимым.


``createExtendedCollection`` --- создание расширенной коллекции (с кастомным классом)
-------------------------------------------------------------------------------------

**Расширенная коллекция** --- коллекция с собственным объявленным классом (наследником ``cord!Collection``).
Расширенные коллекции поддерживают внедрение зависимостей с помощью статического свойства ``@inject``, метод
``browserInit``, который при наличии вызывается только при инициализации на стороне браузера. В расширенной коллекции
можно объявлять дополнительное побличное API.

Метод ``createExtendedCollection`` принимает на вход два аргумента:

* Класс коллекциии --- именно ссылку на конструктор класса, а не строковой путь.
* Параметры --- такие же, как и для ``createCollection``.

В отличие от ``createCollection`` здесь результат асинхронный (из-за вызова ``injectServices``) и результирующая
коллекция возвращается завёрнутой в :term:`промис`.


``createSingleModel`` --- создание коллекции для доступа к одной модели (экземпляру)
------------------------------------------------------------------------------------

Синтаксический сахар для создания single-model коллекций (см. опции ``id`` и ``model`` у ``createCollection``).
Принимает на вход три аргумента:

* ``id`` --- идентификатор требуемой модели.
* ``fields`` --- список полей для этой модели (аналогично ``createCollection``).
* ``extraOptions`` (не обязательно) --- дополнительные опции для ``createCollection``. Обычно не требуются.

Так же, как и ``createCollection``, возвращает коллекцию синхронно, и для получения модели её нужно сперва
синхронизировать с сервером.


``collectionExists`` --- проверка существования коллекции с заданным именем
---------------------------------------------------------------------------

Метод принимает на вход название коллекции и возвращает ``true``, если она зарегистрирована в репозитории.


``getCollection`` --- получить существующую коллекцию по имени
--------------------------------------------------------------

Синхронно возвращает зарегистрированную коллекцию по названию. Если коллекции нет, бросает исключение.


API работы с моделями
=====================

``buildSingleModel`` --- получить модель с заданным ID и набором полей
----------------------------------------------------------------------

Удобный метод для получения модели с известным идентификатором и набором полей. Модель возвращается завёрнутой в
:term:`промис`. Принимает следующие аргументы:

* ``id`` --- идентификатор требуемой модели.
* ``fields`` --- список полей для этой модели (аналогично ``createCollection``).
* ``syncMode`` --- режим синхронизации коллекции с сервером (см. документацию на метод ``sync`` коллекции).
* ``extraOptions`` (не обязательно) --- дополнительные опции для ``createCollection``. Обычно не требуются.


``buildModel`` --- создание модели из простого объекта
------------------------------------------------------

Метод принимает на вход простой объект с полями, синхронно создаёт и возвращает экземпляр модели нужного типа со
всеми нужными методами. Его удобно использовать при создании новой модели или десериализации существующей.

Если на вход передать не простой объект, а экземпляр модели, то это удобный способ клонирования этой модели.

.. warning::

  Создаваемая таким образом модель не привязана ни к какой коллекции, а значит и к репозиторию. Поэтому методы,
  которые приводят к взаимодействию с сервером (``save``, ``delete`` и пр.) не могут быть использованы до тех пор,
  пока модель не привяжется к какой-нибудь коллекции. Для привязки можно использовать метод ``Collection.addModel``
  или метод ``setCollection`` у самой модели.

.. _model-repo-api-buildNewModel:

``buildNewModel`` --- создание новой модели для сохранения
----------------------------------------------------------

Делает то же, что и ``buildModel``, но поля из переданного объекта добавляются в модель с помощью метода ``set``,
считаются "новыми" и будут переданы на сервер в случае вызова ``save``.

.. _model-repo-api-save:

``save`` --- сохранение модели на бекенд-сервере
------------------------------------------------

Метод сохраняет новую модель на сервер или обновляет существующую (в зависимости от наличия идентификатора).
Принимает на вход 2 аргумента:

* Сохраняемая модель.
* ``notRefreshCollections`` (по умолчанию ``false``) --- позволяет заглушить механизм обновления коллекций для
  данного конкретного изменения. Имеет смысл использовать, когда известно, что данное изменение не существенно для
  отображения в пользовательском интерфейсе и для других коллекций данного типа.

Метод возвращает промис с ответом сервера на ``PUT`` или ``POST`` запрос, если всё хорошо, и с ошибкой --- если
что-то пошло не так.

.. note::

  Для удобства у каждой модели есть метод ``save``, который проксирует вызов в метод репозитория. Можно использовать
  оба варианта, однако при создании совсем новых моделей, не привязанных к коллекции, доступен только
  непосредственный вызов ``ModelRepo.save(model)``.


``delete`` --- удаление модели на бекенд-сервере
------------------------------------------------

Удаляет модель на бекенде с помощью ``DELETE`` запроса к соответствующему ReST-ресурсу. Принимает на вход один
аргумент --- удаляемую модель (не идентификатор). Возвращает промис с ответом сервера, если всё хорошо, и с ошибкой,
если что-то пошло не так.

Так же, как и ``save`` имеет дубль-версию в самой модели, использование которой является предпочтительным.
