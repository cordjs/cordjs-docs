**********************
API подсистемы моделей
**********************

API репозитория
===============

Класс репозитория
-----------------

Исходный файл класса репозитория должен располагаться в папке ``models``. Класс репозитория, как правило, называется
с суффиксом ``Repo`` и так же называется исходный файл (с расширением ``.coffee``).

Ниже приведён пример класса со всеми возможными модификациями, которые описаны ниже:

.. code-block:: coffee
  :linenos:
  :caption: public/bundles/hello/example/models/UserRepo.coffee

  class UserRepo extends ModelRepo

    @inject: ['comet']

    restResource: 'user'
    model: UserModel

    actions:
      restorePassword: 'put'

    fieldTags:
      online: [':backendCalc']

    fieldCompareFunctions:
      online: (left, right) ->
        left != right

    predefinedCollections:
      onlineUsers:
        fields: ['login', 'device']
        filterParams:
          online: true

    init: ->
      if CORD_IS_BROWSER
        # какая-то инициализация, например, подписка на live-обновления с сервера

* ``@inject`` --- стандартное :ref:`описание статических зависимостей <di-inject>` для сервис-контейнера.

* ``restResource`` --- часть URL'а запросов к бекенд-сервису, определяющая REST-ресурс, соответствующий данному типу
  моделей. Это единственное обязательное поле при объявлении класса репозитория.

* ``model`` --- класс для моделей данного типа, если он отличается от стандартного ``cord!Model``. Должна указывается
  именно прямая ссылка на конструктор класса, а не строковой путь.

* ``actions`` --- позволяет автоматически добавлять методы-экшны к экземплярам моделей данного типа, которые будут
  делать запросы к урлам вида ``user/1234/restorePassword``. Ключи --- названия методов и завершающей части URL,
  значения --- HTTP-глагол, который должен использоваться для запроса: ``get``, ``put``, ``post`` или ``delete``.

* ``fieldTags`` --- даёт возможность подсказать классу, который формирует REST-запросы, что поле с таким названием
  нужно обрабатывать особым образом с помощью тегов. На момент написания документации поддерживается только тег
  ``:backendCalc``, который позволяет добавить соответствующее поле в параметр ``_calc``, а не в ``_fields``, в
  строке запроса к бекенду.

* ``fieldCompareFunctions`` --- даёт возможность объявить кастомную функцию сравнения на равенство для определённых
  полей. Эта функция будет использоваться при определении изменённости полей модели и необходимости бросать событие
  ``change``. Если специальной функции не объявлено, используется достаточно умный алгоритм сравнения по умолчанию.

* ``predefinedCollections`` --- позволяет объявить коллекции, которые будут созданы сразу при инициализации
  репозитория и могут быть использованы в любое время по имени. Ключ --- название коллекции, значение --- стандартные
  параметры коллекции (см. ниже).

* ``init`` --- метод, предназначенный для выполнения дополнительных инициализаций сразу после создания репозитория.
  Этот метод должен вызываться **явно** в функции-фабрике сервиса сразу после отработки ``injectServices``.


Доступ к репозиториям
---------------------

Для работы с моделями в первую очередь нужно получить доступ к соответствующему репозиторию. Поскольку репозиторий
это обычный сервис в контейнере сервисов, то это можно сделать либо с помощью статического объявления зависимости в
``@inject``, если такое доступно, либо вызовом метода ``serviceContainer.getService('someRepo')``.

Прямой доступ к репозиторию не нужен в том случае, если нужная коллекция или модель зарегистрированы в виде
самостоятельных сервисов.


API работы с коллекциями
------------------------

Репозиторий чаще всего используется для работы с коллекциями: создания/удаления/доступа.


``createCollection`` --- создание динамической коллекции
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Метод принимает на вход объект с параметрами создаваемой коллекции и возвращет (синхронно) экземпляр зарегистрированной
коллекции. Пример:

.. code-block:: coffee
  :linenos:

  userCollection = userRepo.createCollection
    # name: 'allUsers'

    # fixed: false

    # models: [m1, m2, m3, m4, m5]
    # start: 16
    # end: 20
    # rawModelsData: [{ id:1, login: 'david' }]

    # id: 123
    # model: m1

    # accessPoint: 'example'

    fields: [
      'login'
      'name'
      'online'
      'avatar'
    ]

    filter:
      blocked: false

    # filterId: 'predefinedServerSideFilter'
    # filterParams: 'arbitraryParamsFotServerSideFilterWithFilterId'

    orderBy: 'name'
    pageSize: 50

    requestParams:
      additionalCustomParam: 123

    tags:
      'id.any':
        action: 'tagLiveUpdate'

Ниже описание параметров:

* ``name`` --- уникальное название коллекции в рамках своего репозитория. В большинстве случаев название не должно
  задаваться явно и формируется автоматически из остальных параметров. За счёт такого свойства, если в двух разных
  местах попробовать создать коллекции с одинаковыми параметрами, то будет создана только одна и повторно
  использована в обоих местах. Явное название в одновном предназначено для предопределённых в репозитории коллекций.

* ``fixed`` --- флаг, обозначающий, что данная коллекция управляется вручную разработчиком и не должна
  синхронизироваться с сервером. Вместе с этой опцией должна присутствовать опция ``models``.

* ``models`` --- массив экземпляров моделей, которыми "вручную" наполняется коллекция. Может использоваться как для
  ``fixed`` коллекций, так и для начального заполнения из какого-либо кеша обычных коллекций. Вместе с этим
  параметром могут использоваться параметры ``start`` и ``end`` для обозначения границ предзагруженных моделей
  поддержке постраничной загрузки.

* ``start`` --- индекс (с отсчётом от нуля) первой модели из списка ``models`` в общем потенциальном списке моделей
  коллекции с учётом постраничной подгрузки. Работает только в паре с параметром ``models``.

* ``end`` --- индекс (с отсчётом от нуля) последней модели из списка ``models`` в общем потенциальном списке моделей
  коллекции с учётом постраничной подгрузки. Работает только в паре с параметром ``models``.

* ``rawModelsData`` --- аналогично ``models``, но список не готовых моделей, а простых объектов с полями, которые
  предварительно превращаются в модели (полезно при десериализации).

* ``id`` --- идентификатор модели, для которой нужно создать single-model коллекцию. Такая коллекция сможет содержать
  только эту указанную модель. Для неё будут формироваться более оптимальные запросы к серверу.

* ``model`` --- то же, что и ``id``, но передаётся не идентификатор, а готовая модель.

* ``accessPoint`` --- дополнительный сектор пути в URL при ReST-запросе к серверу, который следует добавить к
  ``restResource`` (через ``/``) для запроса данной коллекции. Может понадобится, если какой-либо ресурс имеет какое-то
  особое поведение и набор полей для особой ситуации.

* ``fields`` --- список названий полей, которые должны иметь модели данной коллекции. В зависимости от реализации
  бекенда, можно указывать поля связанных моделей через точку, например ``participant.name``. В этом случае в
  конечной модели поле ``participant`` будет представлено объектом с полем ``name``.

* ``filter`` --- параметры простейшей фильрации по полям в формате ``<название параметра>: <нужное значение>``.
  Добавляются в URL запроса в виде аналогичных query-параметров.

* ``filterId`` --- если бекенд реализует какой-нибудь сложные фильтр, то у него должно быть название (идентификатор),
  которое можно указать в параметре ``filterId`` для использования этого фильтра.

* ``filterParams`` --- произвольные параметры для серверного фильтра, указанного в ``filterId``. Работает только в
  паре с ``filterId``.

* ``orderBy`` --- название или массив названий полей, по которым следует отсортировать список моделей в коллекции.
  Могут использоваться названия полей связанных моделей, как и в ``fields``. Если требуется сортировка в обратном
  порядке, следует использовать символ ``-`` (минус) перед названием поля, например ``-participant.name``.

* ``pageSize`` --- обозначает размер "страницы" (количество моделей) для подгрузки с помощью метода ``getPage``. Речь
  идёт именно о внутренней работе коллекции, а не об отображении списка пользователю. Если этот параметр не указан
  или равен нулю, то постраничная подгрузка не поддерживается.

* ``requestParams`` --- любые произвольные дополнительные параметры в виде объекта (ключ-значение), которые следует
  добавить в queryString URL'а запроса для получения данной коллекции.

* ``tags`` --- подсказки системе автоматического обновления коллекций о том, как себя вести при изменении тех или
  иных полей. Это позволяет сильно оптимизировать количество запросов обновления коллекций к серверу. Подробнее об
  этом в отдельном разделе.

.. warning::

  Коллекция, которую возвращает метод ``createCollection``, скорее всего, не наполнена моделями (не синхронизирована).
  Разработчик должен вызвать асинхронный метод ``sync`` или ``getPage`` у коллекции, прежде чем сможет манипулировать
  её содержимым.


``createExtendedCollection`` --- создание расширенной коллекции (с кастомным классом)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

**Расширенная коллекция** --- коллекция с собственным объявленным классом (наследником ``cord!Collection``).
Расширенные коллекции поддерживают внедрение зависимостей с помощью статического свойства ``@inject``, метод
``browserInit``, который при наличии вызывается только при инициализации на стороне браузера. В расширенной коллекции
можно объявлять дополнительное побличное API.

Метод ``createExtendedCollection`` принимает на вход два аргумента:

* Класс коллекциии --- именно ссылку на конструктор класса, а не строковой путь.
* Параметры --- такие же, как и для ``createCollection``.

В отличие от ``createCollection`` здесь результат асинхронный (из-за вызова ``injectServices``) и результирующая
коллекция возвращается завёрнутой в :term:`промис`.


``createSingleModel`` --- создание коллекции для доступа к одной модели (экземпляру)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Синтаксический сахар для создания single-model коллекций (см. опции ``id`` и ``model`` у ``createCollection``).
Принимает на вход три аргумента:

* ``id`` --- идентификатор требуемой модели.
* ``fields`` --- список полей для этой модели (аналогично ``createCollection``).
* ``extraOptions`` (не обязательно) --- дополнительные опции для ``createCollection``. Обычно не требуются.

Так же, как и ``createCollection``, возвращает коллекцию синхронно, и для получения модели её нужно сперва
синхронизировать с сервером.


``collectionExists`` --- проверка существования коллекции с заданным именем
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Метод принимает на вход название коллекции и возвращает ``true``, если она зарегистрирована в репозитории.


``getCollection`` --- получить существующую коллекцию по имени
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Синхронно возвращает зарегистрированную коллекцию по названию. Если коллекции нет, бросает исключение.


API работы с моделями
---------------------

``buildSingleModel`` --- получить модель с заданным ID и набором полей
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Удобный метод для получения модели с известным идентификатором и набором полей. Модель возвращается завёрнутой в
:term:`промис`. Принимает следующие аргументы:

* ``id`` --- идентификатор требуемой модели.
* ``fields`` --- список полей для этой модели (аналогично ``createCollection``).
* ``syncMode`` --- режим синхронизации коллекции с сервером (см. документацию на метод ``sync`` коллекции).
* ``extraOptions`` (не обязательно) --- дополнительные опции для ``createCollection``. Обычно не требуются.


``buildModel`` --- создание модели из простого объекта
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Метод принимает на вход простой объект с полями, синхронно создаёт и возвращает экземпляр модели нужного типа со
всеми нужными методами. Его удобно использовать при создании новой модели или десериализации существующей.

Если на вход передать не простой объект, а экземпляр модели, то это удобный способ клонирования этой модели.


``save`` --- сохранение модели на бекенд-сервере
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Метод сохраняет новую модель на сервер или обновляет существующую (в зависимости от наличия идентификатора).
Принимает на вход 2 аргумента:

* Сохраняемая модель.
* ``notRefreshCollections`` (по умолчанию ``false``) --- позволяет заглушить механизм обновления коллекций для
  данного конкретного изменения. Имеет смысл использовать, когда известно, что данное изменение не существенно для
  отображения в пользовательском интерфейсе и для других коллекций данного типа.

Метод возвращает промис с ответом сервера на ``PUT`` или ``POST`` запрос, если всё хорошо, и с ошибкой --- если
что-то пошло не так.

.. note::

  Для удобства у каждой модели есть метод ``save``, который проксирует вызов в метод репозитория. Можно использовать
  оба варианта, однако при создании совсем новых моделей, не привязанных к коллекции, доступен только
  непосредственный вызов ``ModelRepo.save(model)``.


``delete`` --- удаление модели на бекенд-сервере
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Удаляет модель на бекенде с помощью ``DELETE`` запроса к соответствующему ReST-ресурсу. Принимает на вход один
аргумент --- удаляемую модель (не идентификатор). Возвращает промис с ответом сервера, если всё хорошо, и с ошибкой,
если что-то пошло не так.

Так же, как и ``save`` имеет дубль-версию в самой модели, использование которой является предпочтительным.


API коллекции
=============

Синхронизация с сервером
------------------------

``sync`` --- низкоуровневая синхронизация
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

После того как коллекция создана с помощью одного из методов репозитория, в неё нужно загрузить модели с
бекенд-сервера, другими словами --- синхронизировать. Только после этого она становится полезной. Основной и самый
низкоуровневый метод для запуска синхронизации --- ``sync``. Она принимает на вход три необязательных аргумента:

* *Строка* **Режим синхронизации** --- определяет то, в какой момент и как завершается промис, который возвращает метод
  ``sync``. Возможные значения: ``:sync`` (по умолчанию), ``:async``, ``:now``, ``:cache`` или ``:cache-only``.
  Подробнее о режимах ниже.

* *Целое число* **Стартовый индекс** (start) --- номер первой модели (отсчёт от нуля) в общем списке для частичной
  загрузки (как LIMIT OFFSET в SQL). Общий список определяется настройками фильтрации и сортировки коллекции.

* *Целое число* **Конечный индекс** (end) --- номер последней модели (отсчёт от нуля) в общем списке для частичной
  загрузки. Если задан старновый индекс, но не задан конечный, то загрузятся все модели, начиная от стартового индекса.

Следует понимать, что синхронизировать коллекцию можно сколько угодно раз, чтобы обновить информацию с сервера.
Коллекция считается *инициализированной* только после первой синхронизации, даже если она была частичной.

.. note::

  Возможность частичной подгрузки по диапазону индексов в общем случае не должна использоваться конечными
  разработчиками, поскольку для этого существуют более высокоуровневые методы *постраничной* подгрузки (которые внутри
  себя используют метод ``sync``). Т.е. в большинстве случаем метод вызывается только с одним аргументом или без
  аргументов.

Метод возвращает саму коллекцию (т.е. себя), завёрнутую в :term:`промис`, который резолвится в разные моменты в
зависимости от выбранного режима синхронизации:

* ``:sync`` --- произвести синхронизацию и отрезолвить результирующий промис только после завершения синхронизации,
  независимо от текущего состояния коллекции. Это самый надёжный метод получить самые актуальные данные с сервера.
  Режим ``:sync`` используется, если метод ``sync`` вызывается без аргументов.

* ``:async`` --- если коллекция проинициилизирована и в ней содержится нужный диапазон моделей (при использовании
  ``start``/``end``), то отрезовлить результат немедленно и запустить фоновую синхронизацию. Иначе, если требуемые
  данные не загружены ни разу, поведение как при ``:sync``.

* ``:now`` --- запустить фоновую синхронизацию, отрезолвить результат немедленно, независимо от текущего состояния
  коллекции (т.е. в коллекции может не оказаться загруженных данных).

* ``:cache`` --- если в локальном кеше есть требуемые данные, то загрузить их и отрезолвить результирующий промис, не
  запуская синхронизации. Иначе, если в кеше нет данных, поведение как при ``:sync``.

* ``:cache-only`` --- как ``:cache``, но если данных в кеше нет, то отреджектить результирующий промис (ошибка) и не
  запускать синхронизацию.


``isInitialized`` --- проверка синхронизированности коллекции
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Возвращает ``true``, если коллекция хотя бы раз синхронизирована после создания.


Постраничная синхронизация
--------------------------

Одна из важных возможностей коллекций --- возможность загружать данные с сервера постранично. Это очень полезно для
работы с большими наборами данных.

Для того, чтобы включить возможность постраничной загрузки, нужно при создании коллекции указать ненулевой параметр
``pageSize``, который определяет размер одной страницы. Нумерация страниц начинается с 1 (единицы). Есть возможность
подгружать страницы как с первой, так и с "середины".

Загруженные страницы в коллекции всегда представляют собой непрерывный диапазон. Например, если сначала была
запрошена первая страница, а затем --- пятая, то будут загружены также страницы со второй по четвёртую.


``getPage`` --- получить модели заданного диапазона страниц
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Метод возвращает завёрнутый в промис список моделей в соответствии с заданным диапазоном страниц. Если нужные
страницы уже загружены, то используются уже загруженные модели (без синхронизации). Если хотя бы одна из нужных
страниц не загружена, то происходит синхронизация всего заданного диапазона в режиме ``:async``.

Метод принимает два аргумента (обязательный только первый):

* *Натуральное число* **firstPage** --- номер первой страницы диапазона. Если второй аргумент не задан, то
  загружается только эта страница.

* *Натуральное число* **lastPage** --- номер последней страницы диапазона.


``getPagingInfo`` --- мета-информации о постраничной загрузке
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Расчитывает и возвращает полезную мета-информацию для работы с постраничной загрузкой. Принимает два необязательных
аргумента:

* *Число* ``selectedId`` --- идентификатор "выбранной" модели, относительно которой нужно расчитать некоторые поля
  результата (см. ниже).

* *Булево* ``refresh`` --- не использовать данные из кеша, форсировать актуализацию с сервера. По умолчанию выключено.

Результат метода --- завёрнутый в промис объект со следующими полями:

* ``total`` --- общее количество моделей в коллекции.
* ``pages`` --- общее количество страниц в коллекции (с учётом параметра ``pageSize``).
* ``selected`` (только если задан ``selectedId``) --- индекс модели с заданным ID в общем списке моделей коллекции
  (отсчёт с нуля).
* ``selectedPage`` (только если задан ``selectedId``) --- номер страницы, в которую входит модель с заданным ID.


``partialRefresh`` --- оптимизированное обновление для больших коллекций
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. todo::

  Автор: Белобров.


``refresh`` --- обновить записи коллекции вокруг заданной модели
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. todo::

  Автор: Белобров.


Методы доступа к моделям
------------------------

``get`` --- получить модель по ID
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Синхронно возвращает модель по заданному ID. Должен вызываться после синхронизации. Если модель в коллекции
отсутствует или нужная страница не синхронизирована, то бросает исключение.


``have`` --- проверка наличия модели по ID
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Проверяет наличие загруженной модели в коллекции по ID. Возвращает ``true`` если модель с заданным ID есть в
коллекции и загружена.


``toArray`` --- получить текущий список моделей
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Синхронно возвращает массив загруженных моделей коллекции. Этот метод не стоит использовать для постраничных
коллекций, поскольку он вернёт только модели из диапазона загруженных в данный момент страниц, что может быть
довольно непредсказуемым поведением. Для постраничных коллекций лучше использовать асинхронный метод ``getPage``.


Другие полезные методы
----------------------

``addModel`` --- добавить модель в коллекцию "вручную"
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Вручную добавляет модель в начало или конец коллекции. Метод полезен для коллекций, управляемых внучную (не
синхронизируемых с сервером). Метод принимает 2 аргумента:

* *Модель* ``model`` --- добавляемая модель.
* *Строка* **position** --- куда добавлять: в начало --- ``:head``, в конец --- ``:tail``. По умолчанию ``:tail``.

Метод полностью синхронен и ничего не возвращает.


``euthanize`` --- удаление коллекции из репозитория и кешей
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Метод позволяет удалить ссылки на коллекцию из репозитория и закешированные данные. Это почти уничтожение коллекции.
Но если какой-нибудь виджет сохранил ссылку на коллекцию, то он сможет с ней работать. Метод не принимает аргументов
и возвращает промис по результатам инвалидации кешей (это асинхронная операция).


``cache`` --- локально закешировать текущее состояние коллекции
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Кеширование коллекции происходит автоматически, но иногда требуется форсировать сохранение в кеш именно текущей
версии. Для этого можно явно вызвать метод ``cache``. Метод не принимает аргументов и возвращает промис с булевым
значением ``true``, если кеширование произошло, и ``false``, если кеширование не произошло (например, потому что
метод вызван на сервере, где кеширование не работает в принципе).


``invalidateCache`` --- очистить кеш коллекции
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Метод форсирует немедленное очищение локального кеша коллекции. Под локальным кешем подразумевается хранилище
браузера, в котором данные сохранятся даже после перезагрузки страницы, а не загруженные в живую коллекцию данные.
Работа с локальным кешем асинхронная, поэтому возвращается промис по результатам операции очистки.


API модели
==========
