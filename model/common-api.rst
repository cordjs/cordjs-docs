**********************
API подсистемы моделей
**********************

API репозитория
===============

.. _model-repo-api-class:

Класс репозитория
-----------------

Исходный файл класса репозитория должен располагаться в папке ``models``. Класс репозитория, как правило, называется
с суффиксом ``Repo`` и так же называется исходный файл (с расширением ``.coffee``).

Ниже приведён пример класса со всеми возможными модификациями, которые описаны ниже:

.. code-block:: coffee
  :linenos:
  :caption: public/bundles/hello/example/models/UserRepo.coffee

  class UserRepo extends ModelRepo

    @inject: ['comet']

    restResource: 'user'
    model: UserModel

    actions:
      restorePassword: 'put'

    fieldTags:
      online: [':backendCalc']

    fieldCompareFunctions:
      online: (left, right) ->
        left != right

    predefinedCollections:
      onlineUsers:
        fields: ['login', 'device']
        filterParams:
          online: true

    init: ->
      if CORD_IS_BROWSER
        # какая-то инициализация, например, подписка на live-обновления с сервера

* ``@inject`` --- стандартное :ref:`описание статических зависимостей <di-inject>` для сервис-контейнера.

* ``restResource`` --- часть URL'а запросов к бекенд-сервису, определяющая REST-ресурс, соответствующий данному типу
  моделей. Это единственное обязательное поле при объявлении класса репозитория.

* ``model`` --- класс для моделей данного типа, если он отличается от стандартного ``cord!Model``. Должна указывается
  именно прямая ссылка на конструктор класса, а не строковой путь.

* ``actions`` --- позволяет автоматически добавлять методы-экшны к экземплярам моделей данного типа, которые будут
  делать запросы к урлам вида ``user/1234/restorePassword``. Ключи --- названия методов и завершающей части URL,
  значения --- HTTP-глагол, который должен использоваться для запроса: ``get``, ``put``, ``post`` или ``delete``. См.
  также :ref:`model-model-api-actions`.

* ``fieldTags`` --- даёт возможность подсказать классу, который формирует REST-запросы, что поле с таким названием
  нужно обрабатывать особым образом с помощью тегов. На момент написания документации поддерживается только тег
  ``:backendCalc``, который позволяет добавить соответствующее поле в параметр ``_calc``, а не в ``_fields``, в
  строке запроса к бекенду.

* ``fieldCompareFunctions`` --- даёт возможность объявить кастомную функцию сравнения на равенство для определённых
  полей. Эта функция будет использоваться при определении изменённости полей модели и необходимости бросать событие
  ``change``. Если специальной функции не объявлено, используется достаточно умный алгоритм сравнения по умолчанию.

* ``predefinedCollections`` --- позволяет объявить коллекции, которые будут созданы сразу при инициализации
  репозитория и могут быть использованы в любое время по имени. Ключ --- название коллекции, значение --- стандартные
  параметры коллекции (см. ниже).

* ``init`` --- метод, предназначенный для выполнения дополнительных инициализаций сразу после создания репозитория.
  Этот метод должен вызываться **явно** в функции-фабрике сервиса сразу после отработки ``injectServices``.


Доступ к репозиториям
---------------------

Для работы с моделями в первую очередь нужно получить доступ к соответствующему репозиторию. Поскольку репозиторий
это обычный сервис в контейнере сервисов, то это можно сделать либо с помощью статического объявления зависимости в
``@inject``, если такое доступно, либо вызовом метода ``serviceContainer.getService('someRepo')``.

Прямой доступ к репозиторию не нужен в том случае, если нужная коллекция или модель зарегистрированы в виде
самостоятельных сервисов.


API работы с коллекциями
------------------------

Репозиторий чаще всего используется для работы с коллекциями: создания/удаления/доступа.


``createCollection`` --- создание динамической коллекции
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Метод принимает на вход объект с параметрами создаваемой коллекции и возвращет (синхронно) экземпляр зарегистрированной
коллекции. Пример:

.. code-block:: coffee
  :linenos:

  userCollection = userRepo.createCollection
    # name: 'allUsers'

    # fixed: false

    # models: [m1, m2, m3, m4, m5]
    # start: 16
    # end: 20
    # rawModelsData: [{ id:1, login: 'david' }]

    # id: 123
    # model: m1

    # accessPoint: 'example'

    fields: [
      'login'
      'name'
      'online'
      'avatar'
    ]

    filter:
      blocked: false

    # filterId: 'predefinedServerSideFilter'
    # filterParams: 'arbitraryParamsFotServerSideFilterWithFilterId'

    orderBy: 'name'
    pageSize: 50

    requestParams:
      additionalCustomParam: 123

    tags:
      'id.any':
        action: 'tagLiveUpdate'

Ниже описание параметров:

* ``name`` --- уникальное название коллекции в рамках своего репозитория. В большинстве случаев название не должно
  задаваться явно и формируется автоматически из остальных параметров. За счёт такого свойства, если в двух разных
  местах попробовать создать коллекции с одинаковыми параметрами, то будет создана только одна и повторно
  использована в обоих местах. Явное название в одновном предназначено для предопределённых в репозитории коллекций.

* ``fixed`` --- флаг, обозначающий, что данная коллекция управляется вручную разработчиком и не должна
  синхронизироваться с сервером. Вместе с этой опцией должна присутствовать опция ``models``.

* ``models`` --- массив экземпляров моделей, которыми "вручную" наполняется коллекция. Может использоваться как для
  ``fixed`` коллекций, так и для начального заполнения из какого-либо кеша обычных коллекций. Вместе с этим
  параметром могут использоваться параметры ``start`` и ``end`` для обозначения границ предзагруженных моделей
  поддержке постраничной загрузки.

* ``start`` --- индекс (с отсчётом от нуля) первой модели из списка ``models`` в общем потенциальном списке моделей
  коллекции с учётом постраничной подгрузки. Работает только в паре с параметром ``models``.

* ``end`` --- индекс (с отсчётом от нуля) последней модели из списка ``models`` в общем потенциальном списке моделей
  коллекции с учётом постраничной подгрузки. Работает только в паре с параметром ``models``.

* ``rawModelsData`` --- аналогично ``models``, но список не готовых моделей, а простых объектов с полями, которые
  предварительно превращаются в модели (полезно при десериализации).

* ``id`` --- идентификатор модели, для которой нужно создать single-model коллекцию. Такая коллекция сможет содержать
  только эту указанную модель. Для неё будут формироваться более оптимальные запросы к серверу.

* ``model`` --- то же, что и ``id``, но передаётся не идентификатор, а готовая модель.

* ``accessPoint`` --- дополнительный сектор пути в URL при ReST-запросе к серверу, который следует добавить к
  ``restResource`` (через ``/``) для запроса данной коллекции. Может понадобится, если какой-либо ресурс имеет какое-то
  особое поведение и набор полей для особой ситуации.

* ``fields`` --- список названий полей, которые должны иметь модели данной коллекции. В зависимости от реализации
  бекенда, можно указывать поля связанных моделей через точку, например ``participant.name``. В этом случае в
  конечной модели поле ``participant`` будет представлено объектом с полем ``name``.

* ``filter`` --- параметры простейшей фильрации по полям в формате ``<название параметра>: <нужное значение>``.
  Добавляются в URL запроса в виде аналогичных query-параметров.

* ``filterId`` --- если бекенд реализует какой-нибудь сложные фильтр, то у него должно быть название (идентификатор),
  которое можно указать в параметре ``filterId`` для использования этого фильтра.

* ``filterParams`` --- произвольные параметры для серверного фильтра, указанного в ``filterId``. Работает только в
  паре с ``filterId``.

* ``orderBy`` --- название или массив названий полей, по которым следует отсортировать список моделей в коллекции.
  Могут использоваться названия полей связанных моделей, как и в ``fields``. Если требуется сортировка в обратном
  порядке, следует использовать символ ``-`` (минус) перед названием поля, например ``-participant.name``.

* ``pageSize`` --- обозначает размер "страницы" (количество моделей) для подгрузки с помощью метода ``getPage``. Речь
  идёт именно о внутренней работе коллекции, а не об отображении списка пользователю. Если этот параметр не указан
  или равен нулю, то постраничная подгрузка не поддерживается.

* ``requestParams`` --- любые произвольные дополнительные параметры в виде объекта (ключ-значение), которые следует
  добавить в queryString URL'а запроса для получения данной коллекции.

* ``tags`` --- подсказки системе автоматического обновления коллекций о том, как себя вести при изменении тех или
  иных полей. Это позволяет сильно оптимизировать количество запросов обновления коллекций к серверу. Подробнее об
  этом в отдельном разделе.

.. warning::

  Коллекция, которую возвращает метод ``createCollection``, скорее всего, не наполнена моделями (не синхронизирована).
  Разработчик должен вызвать асинхронный метод ``sync`` или ``getPage`` у коллекции, прежде чем сможет манипулировать
  её содержимым.


``createExtendedCollection`` --- создание расширенной коллекции (с кастомным классом)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

**Расширенная коллекция** --- коллекция с собственным объявленным классом (наследником ``cord!Collection``).
Расширенные коллекции поддерживают внедрение зависимостей с помощью статического свойства ``@inject``, метод
``browserInit``, который при наличии вызывается только при инициализации на стороне браузера. В расширенной коллекции
можно объявлять дополнительное побличное API.

Метод ``createExtendedCollection`` принимает на вход два аргумента:

* Класс коллекциии --- именно ссылку на конструктор класса, а не строковой путь.
* Параметры --- такие же, как и для ``createCollection``.

В отличие от ``createCollection`` здесь результат асинхронный (из-за вызова ``injectServices``) и результирующая
коллекция возвращается завёрнутой в :term:`промис`.


``createSingleModel`` --- создание коллекции для доступа к одной модели (экземпляру)
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Синтаксический сахар для создания single-model коллекций (см. опции ``id`` и ``model`` у ``createCollection``).
Принимает на вход три аргумента:

* ``id`` --- идентификатор требуемой модели.
* ``fields`` --- список полей для этой модели (аналогично ``createCollection``).
* ``extraOptions`` (не обязательно) --- дополнительные опции для ``createCollection``. Обычно не требуются.

Так же, как и ``createCollection``, возвращает коллекцию синхронно, и для получения модели её нужно сперва
синхронизировать с сервером.


``collectionExists`` --- проверка существования коллекции с заданным именем
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Метод принимает на вход название коллекции и возвращает ``true``, если она зарегистрирована в репозитории.


``getCollection`` --- получить существующую коллекцию по имени
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Синхронно возвращает зарегистрированную коллекцию по названию. Если коллекции нет, бросает исключение.


API работы с моделями
---------------------

``buildSingleModel`` --- получить модель с заданным ID и набором полей
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Удобный метод для получения модели с известным идентификатором и набором полей. Модель возвращается завёрнутой в
:term:`промис`. Принимает следующие аргументы:

* ``id`` --- идентификатор требуемой модели.
* ``fields`` --- список полей для этой модели (аналогично ``createCollection``).
* ``syncMode`` --- режим синхронизации коллекции с сервером (см. документацию на метод ``sync`` коллекции).
* ``extraOptions`` (не обязательно) --- дополнительные опции для ``createCollection``. Обычно не требуются.


``buildModel`` --- создание модели из простого объекта
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Метод принимает на вход простой объект с полями, синхронно создаёт и возвращает экземпляр модели нужного типа со
всеми нужными методами. Его удобно использовать при создании новой модели или десериализации существующей.

Если на вход передать не простой объект, а экземпляр модели, то это удобный способ клонирования этой модели.

.. warning::

  Создаваемая таким образом модель не привязана ни к какой коллекции, а значит и к репозиторию. Поэтому методы,
  которые приводят к взаимодействию с сервером (``save``, ``delete`` и пр.) не могут быть использованы до тех пор,
  пока модель не привяжется к какой-нибудь коллекции. Для привязки можно использовать метод ``Collection.addModel``
  или метод ``setCollection`` у самой модели.

.. _model-repo-api-buildNewModel:

``buildNewModel`` --- создание новой модели для сохранения
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Делает то же, что и ``buildModel``, но поля из переданного объекта добавляются в модель с помощью метода ``set``,
считаются "новыми" и будут переданы на сервер в случае вызова ``save``.

.. _model-repo-api-save:

``save`` --- сохранение модели на бекенд-сервере
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Метод сохраняет новую модель на сервер или обновляет существующую (в зависимости от наличия идентификатора).
Принимает на вход 2 аргумента:

* Сохраняемая модель.
* ``notRefreshCollections`` (по умолчанию ``false``) --- позволяет заглушить механизм обновления коллекций для
  данного конкретного изменения. Имеет смысл использовать, когда известно, что данное изменение не существенно для
  отображения в пользовательском интерфейсе и для других коллекций данного типа.

Метод возвращает промис с ответом сервера на ``PUT`` или ``POST`` запрос, если всё хорошо, и с ошибкой --- если
что-то пошло не так.

.. note::

  Для удобства у каждой модели есть метод ``save``, который проксирует вызов в метод репозитория. Можно использовать
  оба варианта, однако при создании совсем новых моделей, не привязанных к коллекции, доступен только
  непосредственный вызов ``ModelRepo.save(model)``.


``delete`` --- удаление модели на бекенд-сервере
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Удаляет модель на бекенде с помощью ``DELETE`` запроса к соответствующему ReST-ресурсу. Принимает на вход один
аргумент --- удаляемую модель (не идентификатор). Возвращает промис с ответом сервера, если всё хорошо, и с ошибкой,
если что-то пошло не так.

Так же, как и ``save`` имеет дубль-версию в самой модели, использование которой является предпочтительным.


API коллекции
=============

Синхронизация с сервером
------------------------

``sync`` --- низкоуровневая синхронизация
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

После того как коллекция создана с помощью одного из методов репозитория, в неё нужно загрузить модели с
бекенд-сервера, другими словами --- синхронизировать. Только после этого она становится полезной. Основной и самый
низкоуровневый метод для запуска синхронизации --- ``sync``. Она принимает на вход три необязательных аргумента:

* *Строка* **Режим синхронизации** --- определяет то, в какой момент и как завершается промис, который возвращает метод
  ``sync``. Возможные значения: ``:sync`` (по умолчанию), ``:async``, ``:now``, ``:cache`` или ``:cache-only``.
  Подробнее о режимах ниже.

* *Целое число* **Стартовый индекс** (start) --- номер первой модели (отсчёт от нуля) в общем списке для частичной
  загрузки (как LIMIT OFFSET в SQL). Общий список определяется настройками фильтрации и сортировки коллекции.

* *Целое число* **Конечный индекс** (end) --- номер последней модели (отсчёт от нуля) в общем списке для частичной
  загрузки. Если задан старновый индекс, но не задан конечный, то загрузятся все модели, начиная от стартового индекса.

Следует понимать, что синхронизировать коллекцию можно сколько угодно раз, чтобы обновить информацию с сервера.
Коллекция считается *инициализированной* только после первой синхронизации, даже если она была частичной.

.. note::

  Возможность частичной подгрузки по диапазону индексов в общем случае не должна использоваться конечными
  разработчиками, поскольку для этого существуют более высокоуровневые методы *постраничной* подгрузки (которые внутри
  себя используют метод ``sync``). Т.е. в большинстве случаем метод вызывается только с одним аргументом или без
  аргументов.

Метод возвращает саму коллекцию (т.е. себя), завёрнутую в :term:`промис`, который резолвится в разные моменты в
зависимости от выбранного режима синхронизации:

* ``:sync`` --- произвести синхронизацию и отрезолвить результирующий промис только после завершения синхронизации,
  независимо от текущего состояния коллекции. Это самый надёжный метод получить самые актуальные данные с сервера.
  Режим ``:sync`` используется, если метод ``sync`` вызывается без аргументов.

* ``:async`` --- если коллекция проинициилизирована и в ней содержится нужный диапазон моделей (при использовании
  ``start``/``end``), то отрезовлить результат немедленно и запустить фоновую синхронизацию. Иначе, если требуемые
  данные не загружены ни разу, поведение как при ``:sync``.

* ``:now`` --- запустить фоновую синхронизацию, отрезолвить результат немедленно, независимо от текущего состояния
  коллекции (т.е. в коллекции может не оказаться загруженных данных).

* ``:cache`` --- если в локальном кеше есть требуемые данные, то загрузить их и отрезолвить результирующий промис, не
  запуская синхронизации. Иначе, если в кеше нет данных, поведение как при ``:sync``.

* ``:cache-only`` --- как ``:cache``, но если данных в кеше нет, то отреджектить результирующий промис (ошибка) и не
  запускать синхронизацию.


``isInitialized`` --- проверка синхронизированности коллекции
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Возвращает ``true``, если коллекция хотя бы раз синхронизирована после создания.


Постраничная синхронизация
--------------------------

Одна из важных возможностей коллекций --- возможность загружать данные с сервера постранично. Это очень полезно для
работы с большими наборами данных.

Для того, чтобы включить возможность постраничной загрузки, нужно при создании коллекции указать ненулевой параметр
``pageSize``, который определяет размер одной страницы. Нумерация страниц начинается с 1 (единицы). Есть возможность
подгружать страницы как с первой, так и с "середины".

Загруженные страницы в коллекции всегда представляют собой непрерывный диапазон. Например, если сначала была
запрошена первая страница, а затем --- пятая, то будут загружены также страницы со второй по четвёртую.


``getPage`` --- получить модели заданного диапазона страниц
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Метод возвращает завёрнутый в промис список моделей в соответствии с заданным диапазоном страниц. Если нужные
страницы уже загружены, то используются уже загруженные модели (без синхронизации). Если хотя бы одна из нужных
страниц не загружена, то происходит синхронизация всего заданного диапазона в режиме ``:async``.

Метод принимает два аргумента (обязательный только первый):

* *Натуральное число* **firstPage** --- номер первой страницы диапазона. Если второй аргумент не задан, то
  загружается только эта страница.

* *Натуральное число* **lastPage** --- номер последней страницы диапазона.


``getPagingInfo`` --- мета-информации о постраничной загрузке
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Расчитывает и возвращает полезную мета-информацию для работы с постраничной загрузкой. Принимает два необязательных
аргумента:

* *Число* ``selectedId`` --- идентификатор "выбранной" модели, относительно которой нужно расчитать некоторые поля
  результата (см. ниже).

* *Булево* ``refresh`` --- не использовать данные из кеша, форсировать актуализацию с сервера. По умолчанию выключено.

Результат метода --- завёрнутый в промис объект со следующими полями:

* ``total`` --- общее количество моделей в коллекции.
* ``pages`` --- общее количество страниц в коллекции (с учётом параметра ``pageSize``).
* ``selected`` (только если задан ``selectedId``) --- индекс модели с заданным ID в общем списке моделей коллекции
  (отсчёт с нуля).
* ``selectedPage`` (только если задан ``selectedId``) --- номер страницы, в которую входит модель с заданным ID.


``partialRefresh`` --- оптимизированное обновление для больших коллекций
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. todo::

  Автор: Белобров.


``refresh`` --- обновить записи коллекции вокруг заданной модели
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. todo::

  Автор: Белобров.


Методы доступа к моделям
------------------------

``get`` --- получить модель по ID
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Синхронно возвращает модель по заданному ID. Должен вызываться после синхронизации. Если модель в коллекции
отсутствует или нужная страница не синхронизирована, то бросает исключение.


``have`` --- проверка наличия модели по ID
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Проверяет наличие загруженной модели в коллекции по ID. Возвращает ``true`` если модель с заданным ID есть в
коллекции и загружена.


``toArray`` --- получить текущий список моделей
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Синхронно возвращает массив загруженных моделей коллекции. Этот метод не стоит использовать для постраничных
коллекций, поскольку он вернёт только модели из диапазона загруженных в данный момент страниц, что может быть
довольно непредсказуемым поведением. Для постраничных коллекций лучше использовать асинхронный метод ``getPage``.


Другие полезные методы
----------------------

``on`` --- подписка на события коллекции
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Коллекция реализует интерфейс EventEmitter, соответственно можно подписываться (и не забывать отписываться) на её
события. Самое полезное событие --- ``change`` --- возникает, если в коллекции появились или догрузились новые
модели, удалились модели или изменилась любая модель.

.. _models-api-addModel:

``addModel`` --- добавить модель в коллекцию "вручную"
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Вручную добавляет модель в начало или конец коллекции. Метод полезен для коллекций, управляемых внучную (не
синхронизируемых с сервером). Метод принимает 2 аргумента:

* *Модель* ``model`` --- добавляемая модель.
* *Строка* **position** --- куда добавлять: в начало --- ``:head``, в конец --- ``:tail``. По умолчанию ``:tail``.

Метод полностью синхронен и ничего не возвращает.


``euthanize`` --- удаление коллекции из репозитория и кешей
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Метод позволяет удалить ссылки на коллекцию из репозитория и закешированные данные. Это почти уничтожение коллекции.
Но если какой-нибудь виджет сохранил ссылку на коллекцию, то он сможет с ней работать. Метод не принимает аргументов
и возвращает промис по результатам инвалидации кешей (это асинхронная операция).


``cache`` --- локально закешировать текущее состояние коллекции
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Кеширование коллекции происходит автоматически, но иногда требуется форсировать сохранение в кеш именно текущей
версии. Для этого можно явно вызвать метод ``cache``. Метод не принимает аргументов и возвращает промис с булевым
значением ``true``, если кеширование произошло, и ``false``, если кеширование не произошло (например, потому что
метод вызван на сервере, где кеширование не работает в принципе).


``invalidateCache`` --- очистить кеш коллекции
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Метод форсирует немедленное очищение локального кеша коллекции. Под локальным кешем подразумевается хранилище
браузера, в котором данные сохранятся даже после перезагрузки страницы, а не загруженные в живую коллекцию данные.
Работа с локальным кешем асинхронная, поэтому возвращается промис по результатам операции очистки.


API модели
==========

Конструирование модели
----------------------

Модели, соответствующие данным, уже существующим на сервере, конструируются автоматически во время синхронизации
коллекции с сервером. Вручную нужно конструировать только новые сущности, которые должны быть добавлены на сервере.
Для этого можно воспользоваться одним из способов:

* **Конструктор класса модели* --- просто взять класс нужной модели (или просто ``Model``, если нет специального
  класса) и вызвать его конструктор без аргументов, а затем с помощью метода ``set`` добавить полей со значениями.

  .. code-block:: coffee
    :linenos:

    user = new Model
    user.set
      login: 'foo'
      email: 'foo@example.com'
    userRepo.save(user)  # user.save() вызвать нельзя, поскольку нет привязки к коллекции

* :ref:`Метод репозитория buildNewModel <model-repo-api-buildNewModel>` --- отличается от конструктора только тем,
  что сразу внедряед в модель методы-действия из настройки репозитория ``actions``. Кроме того, при таком подходе не
  нужно заботиться о правильном классе модели, репозиторий сам его знает:

  .. code-block:: coffee
    :linenos:

    userRepo.buildNewModel
      login: 'foo'
      email: 'foo@example.com'
    userRepo.save(user)  # user.save() вызвать нельзя, поскольку нет привязки к коллекции


``setCollection`` --- привязка новой модели к коллекции
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Модель сама по себе является простым набором полей, которые можно читать и изменять. Она не "знает", как себя
сохранять, удалять и т.п. Все подобные операции в зоне ответственности репозитория, поэтому, чтобы работало API модели,
которое осуществляет операции с бекендом, необходимо привязать модель к соответствующей коллекции, которая, в свою
очередь, связана с репозиторием.

Один из способов это сделать --- воспользоваться методом коллекции :ref:`addModel <models-api-addModel>`. У модели
есть более низкоуровневый метод ``setCollection``, который принимает на вход коллекцию и просто привязывает модель к
ней.

.. warning::

  Метод ``setCollection``, в отличие от ``Collection::addModel``, не добавляет модель в указанную коллекцию, а просто
  записывает коллекцию в специальное поле модели, что делает доступным API модели, завязанное на коллекцию и
  репозиторий: ``save``, ``delete``, ``on``, ``setAloud`` и вызовы дополнительных внедрённых действий.


Чтение полей
------------

Доступ к полям модели, так же как и :ref:`в контексте <context-read>`, происходит посредством прямого доступа к полям
экземпляра модели:

.. code-block:: coffee
  :linenos:
  :emphasize-lines: 5

  model = userRepo.buildModel
    login: 'foo'
    email: 'foo@example.com'

  console.log "user's login is", model.login

При этом добавлять/изменять поля модели таким же прямым доступом нельзя, поскольку не сработают внутренние механизмы
регистрации изменений для последующей записи на сервер.


``toJSON`` --- получить чистый объект
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Для получение простого объекта с полями модели можно воспользоваться методом ``toJSON``, который выгружает в
результат только поля модели, которые пришли в модель во время конструирования или были выставлены методом ``set``, и
пропускает все внутренние приватные поля модели.


Изменение полей
---------------

Важно понимать, что во время непосредственного вызова методов изменения полей модели остальные экземпляры моделей с
тем же идентификатором и коллекции ничего не "узнают". Событие ``change`` бросается только после сохранения модели на
сервере (вызов ``save``). Только после этого происходит своего рода синхронизация данных между моделями с таким же
ID, и коллекциями, их содержащими. Но это поведение по умолчанию. Способом распространения изменений можно управлять.


``set`` --- добавить/изменить поле
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Добавление/изменение полей модели осуществляется посредством метода ``set``. Существует два варианта использования:

* На входе один аргумент-объект, у которого ключи --- названия полей модели, значения --- соответствующие новые
  значения. С помощью этого варианта можно добавить/изменить несколько полей за один вызов.
* На входе два аргумента: первый --- строковое название поля, второй --- новое значение поля. Так можно изменить
  значение только одного поля, но такой способ значительно удобнее, если само название поля является динамическим и
  лежит в другой переменной.

Примеры:

.. code-block:: coffee
  :linenos:

  user.set(login: 'foo')
  user.set
    login: 'foo'
    email: 'foo@example.com'

  user.set('login', 'foo')
  fieldName = 'login'
  user
    .set(fieldName, 'foo')
    .set(email: 'foo@example.com')

Метод ``set`` отрабатывает синхронно и возвращает саму модель (``this``), чтобы можно было писать цепочки вызовов.


``setAloud`` --- изменить поле с немедленным оповещением
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

В некоторых ситуациях необходимо уведомить подсистему моделей об изменении поля ещё до того, как изменённое состояние
будет сохранено на сервере. Для этого можно использовать метод ``setAloud``, который принимает на вход два аргумента:

* *Строка* ``key`` --- название изменяемого поля модели.
* *Любой тип* ``val`` --- значение поля.

Событие ``change`` возникнет сразу после изменения значения поля и остальные экземпляры моделей с тем же ID смогут
локально обновить свои поля в соответствии с этим изменением.

Метод, так же как и ``set``, возвращает саму модель для удобства.


``emitLocalCalcChange`` --- оповестить об изменении произвольного поля
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Данный метод не изменяет непосредственно значение поля модели, несмотря на то, что указан в этом подразделе. Он
предназначен для оптимизации определённых ситуаций, когда после определённого изменения разработчик
знает, что бекенд изменит какое-либо зависимое поле.

Например, если в группу пользователей добавить нового пользователя, то, если у группы есть рассчитываемое поле
*количество пользователей*, то его значение увеличится на 1. Чтобы не запускать синхронизацию модели группы с
сервером (что может быть тяжёлой операцией и требует взаимодействия через медленную сеть), можно воспользоваться
методом ``emitLocalCalcChange``, чтобы сообщить подсистеме моделей о *локально-вычисленном изменении* поля модели.
Метод принимает на вход 2 аргумента:

* *Строка* ``path`` --- название (или, если это сложное поле связанной модели, путь через точки) поля модели,
  изменение которого мы хотим "предсказать".
* *Любой тип* ``val`` --- значение этого поля, которое мы "угадали".

Метод не изменяет непосредственно указанное поле у модели, у которой он вызван. Этого поля может и не быть в рамках
коллекции, к которой принадлежит эта модель. Вместо этого происходит оповещение всех коллекций о том, что изменилось
такое-то поле и модели с таким-то ID. Если поле есть в параметре ``fields`` коллекции и в ней содержится модель с
таким ID, то у этой модели обновляется значение указанного поля.


Взаимодействие с сервером
-------------------------

``save`` и ``delete``
^^^^^^^^^^^^^^^^^^^^^

Методы ``save`` и ``delete`` не принимают аргументов и являются синтаксическим сахаром для вызова :ref:`аналогичных
методов репозитория <model-repo-api-save>` для данной модели.

.. _model-model-api-actions:

Внедрённые методы из настройки ``actions``
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Если в :ref:`классе репозитория <model-repo-api-class>` указано свойство ``actions``, то при создании экземпляров
моделей в рамках этого репозитория в них внедряются методы, которые приводят к соответствующим API-запросам к бекенду.
Методы принимают на вход объект с параметрами запроса (если нужны) и возвращают результат API-вызова, завёрнутый в
промис. Пример:

.. code-block:: coffee
  :linenos:
  :emphasize-lines: 11

  class UserRepo extends ModelRepo

    restResource: 'user'

    actions:
      restorePassword: 'put'

  # где-то в виджете

  @userRepo.buildSingleModel(123).then (user) ->
    user.restorePassword(secretAnswer: 'baby')
  .then (response) ->
    console.log 'password restore token is', response.token
  .catch (err) ->
    console.error 'password restore failed!', err
