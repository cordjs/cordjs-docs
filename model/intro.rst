********************************************************************
Ознакомление с архитектурой и базовыми элементами слоя Модели данных
********************************************************************

В CordJS основной упор сделан на слое представления (виджете). Однако, сколь-либо серьёзное приложение очень трудно
разрабатывать и поддерживать без ещё одного слоя абстракции --- моделей, или, иначе говоря, слоя работы с данными,
поступающими из бекенд-сервиса.

Основная функция слоя работы с данными --- обеспечение удобного API для запроса и изменения данных на бекенде, а
также автоматическия или полуавтоматическая актуализация данных с сервера и представлений, завязанных на изменяемые
данные.


Три сущности: репозиторий, коллекция, модель
============================================

В CordJS слой работы с данными представлен тремя типами сущностей:

* **Модель** --- простое объектное представление бизнес-логической сущности (*entity*), строчку в БД, например
  *пользователь* или *заказ*.
* **Коллекция** --- набор отфильтрованных и отсортированных по каким-либо признакам однотипных моделей с заданным
  набором полей.
* **Репозиторий** --- сервис, предоставляющий API для работы с данным типом моделей. Знает как взаимодействовать с
  бекендом. Является владельцем всех коллекций для данного типа.

Для получения роботоспособного типа, необходимо объявить сервис *репозитория* для данного типа, далее с помощью него
можно создать *коллекцию*, указав условия фильтрации, сортировки и набор необходимых полей, которая после синхронизации
серверов "наполнится" соответствующими *моделями*, которые можно модифицировать и сохранять обратно в бекенд.


Репозиторий
===========

Репозиторий с точки зрения исходных кодов представляет собой класс-наследник от ``cord!ModelRepo``, который
зарегистрирован в виде сервиса в конфиге своего бандла. Главное, что определяет репозиторий, название ReST ресурса, к
которому нужно обращаться по ReST API для получения моделей данного типа:

.. code-block:: coffee
  :linenos:
  :caption: public/bundles/hello/example/models/UserRepo.coffee

  define [
    'cord!ModelRepo'
  ], (ModelRepo) ->

    class UserRepo extends ModelRepo

      restResource: 'user'


.. code-block:: coffee
  :linenos:
  :caption: public/bundles/hello/example/config.coffee

  define ->
    services:
      userRepo:
        deps: ['serviceContainer']
        factory: (get, done) ->
          require ['cord-m!/hello/example//UserRepo'], (UserRepo) ->
            get('serviceContainer').injectServices(new UserRepo).then (repo) ->
              repo.init()
              done(null, repo)
            .catch (e) -> done(e)

В репозитории реализовано непосредственное взаимодействие с бекенд-сервером. Конечным разработчиком репозитории
используются в основном только для того, чтобы создавать коллекции. Репозиторий является владельцем всех коллекций,
которые были созданы с помощью него.

Коллекция
=========

Коллекции, как правило, не представлены в виде отдельных статических исходников, и являются динамически создаваемыми
с помощью метода репозитория ``createCollection()`` экземплярами класса ``cord!Collection``. Существует также
возможность создавать типизированные коллекции, у которых есть собственный класс (наследник ``Collection``) с
дополнительными методами --- их в CordJS принято называть *расширенными*.

Коллекция характеризуется следующими свойствами:

* **Тип модели** --- репозиторий, который создал данную коллекцию, определяет тип моделей, которые коллекция будет
  содержать.
* **Класс коллекции** --- по умолчанию это базовый класс ``Collection``, для расширенных коллекций он кастомный и
  указывается явно.
* **Фильтр** --- условия фильтрации моделей. Что-то вроде ``WHERE`` в SQL-запросе.
* **Сортировка** --- каким образом (в простейшем случае --- по какому полю) будет отранжирован список моделей
  коллекции.
* **Набор полей** --- какие поля из множества возможных полей для данного типа следует загрузить с сервера. Поскольку
  на сервере обычно реализована реляционная схема данных, то поддерживаются сложные поля с "проваливанием" по связям
  между таблицами.

Коллекция умеет кешировать себя в локальное хранилище браузера (для этого используется библиотека `localForage
<http://mozilla.github.io/localForage/>`_), а также синхронизироваться (обновляться) с сервером по запросу.

Коллекция *владеет* своими моделями, т.е. модель существует только в рамках своей коллекции и не является
самостоятельной сущностью.


Модель
======

Так же, как и коллекция, модель чаще всего не представлена отдельным классом в исходниках и является динамически
создаваемым в процессе формирования коллекции экземпляром класса ``cord!Model``. Однако, существует возможность
создавать кастомный класс модели, наследуемый от ``Model``, чтобы дополнять его какими-либо полезными методами,
специфическими для данного типа. Для этого нужно переопределить динамическое поле ``model`` у репозитория:

.. code-block:: coffee
  :linenos:
  :caption: public/bundles/hello/example/models/UserRepo.coffee
  :emphasize-lines: 15

  define [
    'cord!Model'
    'cord!ModelRepo'
  ], (Model, ModelRepo) ->

    class UserModel extends Model

      encryptPassword: (password) ->
        'stub'


    class UserRepo extends ModelRepo

      restResource: 'user'
      model: UserModel

Модель обладает тем набором полей, который задан в коллекции. У модели всегда есть поле ``id`` --- уникальный
идентификатор в рамках типа данных. Разные коллекции одного и того же типа могут содержать модели с одним и тем же
идентификатором, но это разные экземпляры, напрямую друг с другом не связанные, и у них может быть разный набор полей.


Общие принципы работы
=====================

Реализация подсистемы моделей довольна сложна. Внутри она пытается решить нелёгкую задачу --- обеспечить максимальную
целостность данных в условиях, когда одна и та же сущность может находиться в разных коллекциях.

Механизмы взаимодействия и синхронизации основаны на событиях изменения ``change`` моделей и коллекций. Модели и
коллекции реализуют интерфейс ``EventEmitter`` и генерируют событие ``change`` каждый раз, когда в них что-то меняется.

Если у какой-то модели изменилось поле, это изменение по-умному распространяется на модели других коллекций с тем же
идентификатором. Кроме того, существует механизм, позволяющий автоматически обновлять (синхронизировать) коллекцию с
сервера, поскольку изменение поля модели может повлиять на фильтрацию. И так далее.
