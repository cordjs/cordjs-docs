*******************************************************************
Работа с зависимостями между файлами (модулями) с помощью RequireJS
*******************************************************************

Каждый coffee-файл представляет собой javascript-модуль. Модули зависят друг от друга. В javascript-мире существует
два альтернативных подхода для организации модулей:

* Синхронный **CommonJS**. Это основной способ работы в среде Node.js. В асинхронной среде браузера работу в формате
  CommonJS обеспечивают с помощью костыля под названием Browserify.

* Асинхронный **AMD**. Этот подход более естественен для браузеров и к тому же позволяет подгружать код частями, что
  для большого проекта может быть очень важным.

В CordJS повсеместно используется подход `AMD <https://github.com/amdjs/amdjs-api/wiki/AMD>`_ с использованием самой
популярной библиотеки, которая его реализует --- `RequireJS <http://requirejs.org/>`_.

Пример модуля:

.. code-block:: coffee
  :linenos:

  define [  # массив адресов зависимостей
    'dep1'
    'dep2'
  ], (dep1, dep2) ->  # функция-конструктор данного модуля, перечисленные выше зависимости передаются в качестве аргументов

    self =
      fn1: ->
        dep1.fn1()

      fn2: ->
        dep2.fn1()

    # результат функции-конструктора и будет тем, что получит другой модуль, если подключит этот в качестве зависимости
    self


Что такое AMD и по какому принципу всё работает, можно почитать в документации RequireJS. Эта глава посвящена в
основном адресации различных модулей в рамках структуры проекта на CordJS.

.. note::

  RequireJS позволяет использовать модули, написанные в формате AMD не только в браузере, но и в окружении Node.js.
  Это позволяет одному и тому же коду работать в обоих средах.


Различные варианты адресации модулей
====================================

В определении модуля (вызов ``define``) указывается список адресов модулей, от которых зависит данный модуль. Адрес
модуля-зависимости можно задать одним из следующих способов:

* **Просто название модуля** (без каких-либо слешей) --- такой способ удобен и возможен только для модулей,
  присутствующих в папке ``node_modules`` (при работе на серверной стороне), или на браузерной стороне для модулей,
  для которых специальным образом объявлены алиасы в конфигурации RequireJS.

* **Относительный путь** --- если модуль находится по соседству в той же папке или в дочерней папке, то имеет смысл
  указать относительный путь к модулю в терминах файловой системы (начинающийся с ``./``).

* **Абсолютный путь** --- чтобы добраться к любому модулю в рамках директории ``public`` проекта, можно указать
  полный путь, начиная от этой директории (не включительно), но без ``/`` в начале.

* **Специальная адресация CordJS** (т.н. *канонические* пути) --- CordJS реализует несколько плагинов для RequireJS,
  которые позволяют использовать удобные сокращённые пути к модулям в рамках директории ``public/bundles``. Подробнее
  об этом в следующем разделе.

Ниже пример с использованием всех вариантов:

.. code-block:: coffee
  :linenos:
  :caption: public/bundles/hello/example/widgets/someWidget/SomeWidget.coffee

  define [
    'underscore'                                 # просто название модуля
    './child/Child'                              # относительный путь
    'vendor/datepicker/js/bootstrap-datepicker'  # абсолютный путь
    'cord!Widget'                                # специальный путь к объекту ядра
    'cord-w!/hello/example//someWidget/Child'    # специальный путь к тому же виджету, что и ./child/Child
  ], (_, Child, datapicker, Widget, Child1) ->

    class SomeWidget extends Widget

      # ...


Канонический формат путей в файлам CordJS
=========================================

Для js-модулей, расположенных в папке ``public/bundles`` (а это б\ *о*\ льшая часть исходников), в CordJS реализовано
несколько RequireJS `плагинов <http://requirejs.org/docs/plugins.html>`_ для сокращения длины путей.

Плагин RequireJS используется, если в начале пути к зависимости добавить его название с восклицательным знаком.


``cord!``
---------

Наиболее универсальный вариант, позволяющий адресовать любой модуль в рамках папки ``bundles``. У него есть два
варианта использования:

* Если путь начинается со слеша, то он интерпретируется, как обычный путь к файлу относительно папки ``bundles``.
  Например ``cord!/cord/core/Widget`` будет раскрыт в файл ``public/bundles/cord/core/Widget.js``.

* Для удобного доступа к базовым классам и утилитам ядра фреймворка с плагином ``cord!`` можно писать относительные
  пути (без слеша в начале), и они будут интерпретироваться, как путь к файлу относительно корня бандла ``cord/core``.
  Например, ``cord!Widget`` будет раскрыт в тот же файл ``public/bundles/cord/core/Widget.js``.


``cord-w!``
-----------

Плагин ``cord-w!`` предназначен только для адресации классов виджетов. Он делает два сокращения: вместо ``/widgets/``
нужно писать ``//`` (двойной слеш), и название папки виджета опускается. Возможны следующие варианты использования:

* Если путь начинается со слеша, то он интерпретируется как "абсолютный" относительно папки ``bundles``. Например,
  ``cord-w!/hello/example//SomeWidget`` ракрывается в файл
  ``public/bundles/hello/example/widgets/someWidget/SomeWidget.js``. Если ``cord-w!`` используется напрямую в
  функциях ``define`` или ``require``, то работает только такой "абсолютный" вариант, а относительный путь указать
  нельзя, поскольку RequireJS не предоставляет плагинам информацию о контексте.

* Если путь начинается с двойного слеша, то он интерпретируется относительно папки ``widgets`` текущего бандла.
  Например ``cord-w!//someWidget/Child`` в контексте виджета ``/hello/example//SomeWidget`` раскроется в файл
  ``public/bundles/hello/example/widgets/someWidget/child/Child.js``.

* Если путь не начинается со слеша, то он должен иметь следующий формат ``cord-w!common//MainMenu`` и
  интерпретируется как соседний бандл в том же пространстве имён что и текущий (контекстный). Такой путь в контексте
  виджета ``/hello/example//SomeWidget`` раскроется в файл ``public/bundles/hello/common/widgets/mainMenu/MainMenu.js``.

Относительные пути используются без приставки ``cord-w!`` в атрибуте ``type`` для плагинов ``#widget`` и ``#extend``
в шаблоне виджета, в методах динамического создания дочерних виджетов, а также в конфигурации :term:`роутов <роут>`
(только вариант с текущим бандлом).

.. warning::

  Несмотря на то что к классу виджета можно получить доступ и с помощью плагина ``cord!``, этого не следует делать.
  Нужно всегда использовать плагин ``cord-w!``, поскольку, помимо "раскрытия" пути, он добавляет важную системную
  информацию к классу виджета, без которой виджет не сможет корректно работать.


``cord-m!``
-----------

Подобно плагину ``cord-w!``, ``cord-m!`` выполняет узкую функцию по доступу к классам моделей (любому классу,
расположенному в папке ``models`` в бандле. Использование относительных путей для ``cord-m!`` не имеет практического
смысла. ``cord-m!/hello/example//UsersRepo`` превращается в ``public/bundles/hello/example/models/UsersRepo.js``. Т.е.
при использовании ``cord-m!`` ``/models/`` заменяется на ``//`` (двойной слеш).

Модели следует использовать только посредством ``cord-m!``, а не ``cord!``.


Динамические зависимости
========================

В некоторый случаях невозможно указать зависимость в объявлении модуля (вызов ``define``), например, когда класс
должен работать на серверной стороне, в зависимостях модуля невозможно указать jQuery, поскольку он не работает в
окружении Node.js, но один из методов класса вызывается только на стороне браузера и требует jQuery. В таких редких
случаях можно подгрузить зависимость *динамически* внутри самого метода. Это можно сделать двумя способами:

* Используя функцию ``require``, которая всегда доступна и работает так же, как и ``define``.

* Используя специальный статический метод ``Future.require()``, который возвращает загруженные модули-зависимости не
  в виде callback-функции, а в виде :term:`промиса <Промис>`.

.. code-block:: coffee
  :linenos:

  define [
    'cord!utils/Future'
  ], (Future) ->

    class SomeService

      browserOnlyMethod: ->
        # callback-подход
        require ['jquery', 'cord!utils/DomHelper'], ($, DomHelper) ->
          DomHelper.replace($('.container'), $('<div></div>')

        # промис-подход (рекомендовано)
        Future.require('jquery', 'cord!utils/DomHelper').spread ($, DomHelper) ->
          DomHelper.replace($('.container'), $('<div></div>')

.. _requirejs-config:

Конфигурация RequireJS в ``config.coffee`` бандла
=================================================

На серверной стороне npm-модули можно указать в качестве зависимости только по имени. При этом он будет загружен из
папки ``node_modules``. На стороне браузера папка ``node_modules`` недоступна, а внешние зависимости должны лежать в
папке ``public/vendor``. Для того, чтобы одна и та же библиотека, работающая на и на сервере и в браузере, была
доступна по своему названию, необходимо сконфигурировать `короткий алиас для пути в RequireJS
<http://requirejs.org/docs/api.html#config-paths>`_.  В CordJS для этого предусмотрен специальный ключ в конфиге бандла:

.. code-block:: coffee
  :linenos:
  :caption: public/bundles/hello/example/config.coffee

  define ->
    requirejs:
      paths:
        unserscore: 'vendor/underscore/underscore'
        moment:     'vendor/moment/moment'

Таким образом, можно указать любую дополнительную конфигурацию для RequireJS, которая будет действовать только на
стороне браузера.

Часто выручает возможность использовать `конфигурацию shim <http://requirejs.org/docs/api.html#config-shim>`_,
которая позволяет сделать совместимыми с RequireJS практически любую библиотеку, не поддерживающую AMD.
