*****************************************
Роуты --- подсистема переключения экранов
*****************************************

Роуты определяют, какой корневой виджет и с какими входящими параметрами должен быть показан в ответ на запрос
определённого URL'а.

Каждый бандл определяет свою конфигурацию роутов касаемо страниц (экранов), которые реализует этот бандл. На этапе
инициализации конфигурации роутов из всех включённых бандлов объединяются в одну "карту". Фреймворк не обеспечивает
никакой защиты от конфликтов путей роутов, об этом должен позаботиться разработчик, например, используя в каждом
бандле свой уникальный префикс для путей.


Стандартная конфигурация роутов
===============================

Конфигурация роутов располагается в главном конфигурационном файле бандла ``config.coffee`` под ключом ``routes``.

Есть несколько модификаций (форматов) объявления роута, но в подавляющием большинстве случаев это выглядит так:

.. code-block:: coffee
  :linenos:
  :caption: public/bundles/hello/example/config.coffee

  define ->
    routes:
      '/':
        widget: '//MainPage'

      '/users/:userId':
        widget: '//UserCardPage'
        params:
          showExtendedInfo: false

Конфигурация представляет собой объект, ключами которого являются шаблоны путей URL'ов, а значениями --- набор свойств,
определяющих, как должен обрабатываться такой URL.

Главное свойство ``widget`` указывает на корневой виджет, который представляет страницу целиком, которая должна
отобразиться. Поскольку это конфиг бандла, то здесь можно (и желательно) использовать относительный канонический путь
к виджету (начинающийся с ``//``).

В свойстве ``params`` перечислены параметры, которые будут переданы этому виджету. Кроме того, в качестве параметров
в видет передаются реальные значения секций пути в пришедшем URL, которые обозначены в формате
``:<название параметра>`` в ключе роута (см. ``:userId`` в примере).


Форматы шаблона URL
-------------------

Ключ роута (шаблон URL) может быть задан в одном из двух форматов:

* Простой формат с плейсхолдерами-параметрами (``:userId`` в предыдущем примере).
* Регулярное выражение.

При использовании простого формата следует учитывать следующие особенности:

* Шаблон всегда должен начинаться со слеша (``/``).
* Название именованного параметра-подстановки должно состоять из латинских букв и цифр.
* Ограничительным символом для именованных параметров в пути является ``/`` или конец пути.
* Наличие завершающего слеша ``/`` не имеет значения --- будет работать и так, и так.
* С помощью простого формата невозможно получить параметры из queryString (то, что после вопросика). Кроме того,
  такие пути (с вопросиком) не будут сопоставляться простому шаблону.


Использование регулярных выражений в качестве шаблона URL
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Пример роута, заданного регулярным выражением:

.. code-block:: coffee
  :linenos:

  routes:
    '^/tasks/filters/\\:filterId/?(\\?nav=.+)?$':
      widget: '/megaplan/mobile/common//layouts/SwipeRouterPage'
      regexp: true

Особенности:

* Необходимо явно указывать свойство роута ``regexp: true``.
* Именованные параметры-плейсхолдеры тоже можно указывать, но необходимо экранировать двоеточие указанным способом
  ``\\:filterId``.
* Все параметры, переданные в queryString (после вопросика) будут присоединены в списку параметров виджета,
  независимо от того, присутствуют они в регулярном выражении или нет. Регулярное выражение может только повлиять на
  то, сопоставится ли входящий URL с данным роутом.
* Обратная генерация URL (через свойство ``routeId``) для таких роутов невозможна (см. ниже).


Роут-callback
=============

Несмотря на то что CordJS предназначен только для разработки фронтенд приложений и серверная часть по задумке должна
только отдавать готовые странички, иногда удобно запрограммировать какое-либо действие, не вписывающееся в это
определение.

Для реализации нестандартного поведения на серверной стороне можно создать роут, который приведёт к выполнению
произвольной функции, которая полностью управляет тем, что будет выполнено и что будет возвращено в ответ на запрос:

.. code-block:: coffee
  :linenos:

  routes:
    '^/attach/.+':
      callback: (inputParams, callback) ->
        serviceContainer = inputParams.serviceContainer

        response = serviceContainer.get('serverResponse')
        request = serviceContainer.get('serverRequest')

        response.setHeader 'Set-Cookie', 'attachRedirect=1'
        response.shouldKeepAlive = false
        response.writeHead 302,
          Location: request.url

        callback?()

      regexp: true

Вместо свойства ``widget`` у роута указывается свойство ``callback`` с функцией, которая будет выполнена в случае
совпадения входящего URL с данным роутом. Функции на вход передаются два аргумента:

* Объект с двумя ключами:

  * ``serviceContainer`` --- контейнер сервисов, с помощью которого можно получить доступ к объектам ``request`` и
    ``response`` веб-сервера Node.js, а также к любым другим сервисам, объявленным в приложении.
  * ``params`` --- объект с параметрами от роута, полученными из свойства роута ``params`` и именованных параметров
    из шаблона URL.

* Callback-функция, которую нужно вызывать, когда функция-обработчик завершит свою работу. ``response.end()``
  выполняется именно во время вызова этой callback-функции, и не должен вызываться в самой функции-обработчике запроса.


Ранняя проверка аутентификации с помощью параметра ``requireAuth``
==================================================================

CordJS предоставляет сервис ``api`` для более-менее универсального выполнения ReST-запросов к бекенд-приложению. Этот
сервис поддерживает аутентификацию через протокол OAuth2. В приложениях, у которых часть страниц доступна только
аутентифицированным пользователям, при попытке зайти на такую страницу без аутентификации необходимо перенаправлять
пользователя на страницу логина.

Для того, чтобы это не стало "сюрпризом", когда половина страницы уже отрендерилась, а виджет, который делает запрос
через сервис ``api``, вдруг выясняет, что данную страницу показывать нельзя, роутер поддерживает возможность
"ранней" проверки аутентификации в момент, когда процесс рендеринга корневого виджета ещё не запущен.

Всё просто --- достаточно добавить свойство ``requireAuth: true`` в объявлении роута, который должен работать только
в закрытой зоне приложения. CordJS автоматически проверит аутентификацию и сделает нужный редирект в соответствие с
настройками сервиса ``api``.


"Обратная" генерация URL по ``routeId``
=======================================

CordJS поддерживает "обратную" генерацию URL'ов --- когда по некоему идентификатору и параметрам на выходе получается
URL, соответствующий нужному роуту.

Данное поведение поддерживается с помощью двух свойств роута:

* ``routeId`` --- уникальный строковой идентификатор роута.
* ``shim`` --- маппинг имён параметров (обратите внимание на название параметра в выделенных строках в примере). Это
  удобно в некоторых случаях, когда в одном и том же месте необходимо получить URL к разным типам объектов (роутам) в
  зависимости от каких-либо динамических свойств, а названия параметров в этих роутах отличаются --- своего рода
  роут-полиморфизм.

.. code-block:: coffee
  :linenos:
  :emphasize-lines: 2,6,8

  routes:
    '/tasks/my/:taskId/':
      widget: '//projectsPage/ProjectsPageWrapper'
      routeId: 'task.task'
      shim:
        taskId: 'id'

  router.urlTo('task.task', id: 123)  # --> /tasks/my/123/

Обратный URL можно получить двумя способами:

* Используя метод ``urlTo(routeId, params)`` у роутера (сервис ``router``).
* В шаблоне виджета, используя плагин :ref:`#url`.

.. warning::

  Обратная генерация URL недоступна для роутов, заданных с помощью регулярных выражений (``regexp: true``).


Проброс параметров с помощью ``mergeParams``
============================================

В некоторых приложениях, например, мобильных, логика роутинга отличается от той, что реализована в CordJS. В таком
случае удобно создать базовый виджет, который реализует альтенративную логику роутинга (с анимациями и прочим). Но
при этом базовое управление URL'ами и переходами осуществляется роутером CordJS.

В такой ситуации необходим удобный механизм проброса входящих параметров от роутера CordJS в кастомному роутеру
приложения. Для этого предназначено свойство роута ``mergeParams``:

.. code-block:: coffee
  :linenos:

  '^/crm/\\:filterId/\\:contractorId/?(\\?nav=.+)?$':
    widget: '/megaplan/mobile/common//layouts/SwipeRouterPage'
    regexp: true
    mergeParams: ['filterId', 'contractorId']
    params:
      contentWidget: '/megaplan/mobile/crm//CrmCardPageContent'
      contentParams: {}

Значение свойства ``mergeParams`` список названий параметров, которые должны быть собраны в один специальный
параметр-объект ``__mergedParams``.

В примере на входе виджета ``SwipeRouterPage`` будут не только параметры ``filterId``, ``contractorId``,
``contentWidge`` и ``contentParams``, но и параметр ``__mergedParams`` со значением:

  {
    filterId: 123,
    contractorId: 123
  }
