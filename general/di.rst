*******************************************************************************
Dependency Injection --- подсистема внедрения зависимостей и контейнер сервисов
*******************************************************************************

В CordJS поддерживается довольно простая схема внедрения зависимостей:

* Есть центральный контейнер сервисов (``serviceContainer``), который аккумулирует все сервисы из конфигурационных
 файлов (``config.coffee``) включённых бандлов.

* Внедрение зависимостей происходит в виде динамических свойств создаваемого сервиса на основе статического свойства
  ``@inject``, объявленного у его класса.

* Свойство ``@inject`` поддерживается также в регламентированных классах, не являющихся именованными сервисами ---
  :ref:`виджетах <widget-di>` и behaviour-классах.


Объявление сервиса
==================

Для того, чтобы сервис стал доступен для внедрения в качестве зависимости, его необходимо объявить в конфиге бандла,
в котором находится его исходный код. Для этого в файле ``config.coffee`` предназначен специальный раздел ``services``:

.. code-block:: coffee
  :linenos:
  :caption: public/bundles/hello/example/config.coffee

  define ->
    routes:
      # ...
    services:
      timeZone:
        deps: ['serviceContainer']
        factory: (get, done) ->
          require ['cord!/hello/examples/services/TimeZone'], (TimeZone) ->
            timeZone = new TimeZone
            get('serviceContainer').injectServices(timeZone)
              .then ->
                done(null, timeZone)
              .failAloud()
              .catch (e) -> done(e)

Ключ в объявлении (``timeZone``) --- уникальное название сервиса, по которому его будут использовать в качестве
зависимости и по которому он будет доступен через ``serviceContainer``.

Обязательным свойством в объявлении сервиса является только ``factory`` --- функция-фабрика, которая конструирует
экземпляр сервиса. Она принимает на вход два аргумента-функции:

* Функция ``get`` даёт синхронный доступ к сервисам, которые требуются для работы данной функции-фабрики. Названия этих
  сервисов должны быть перечислены в свойстве ``deps``.
* Функция ``done``, которая должна быть вызвана из функции-фабрики, когда экземпляр сервиса будет готов (зачастую,
  просесс создания сервиса асинхронен). Первый аргумент функции ``done`` --- ошибка, если что-то пошло не так, второй
  --- сам экземпляр сервиса.


Сервисы только для браузера/сервера
-----------------------------------

Некоторые сервисы работают только на стороне сервера либо браузера, либо имеют разные реализации для разных окружений.
В CordJS есть возможность объявить сервис только для браузера или сервера с помощью специальных ключей ``:server`` и
``:browser``, добавляющих дополнительный уровень в конфиг:

.. code-block:: coffee
  :linenos:
  :caption: public/bundles/hello/example/config.coffee

  define ->
    routes:
      # ...
    services:
      timeZone:   # работает везде
        deps: ['serviceContainer']
        factory: (get, done) ->
          ...

      ':server':
        router:   # реализация только для сервера
          factory: (get, done) ->
            done(null, new ServerSideRouter)

      ':browser':
        router:   # реализация только для браузера
          factory: (get, done) ->
            done(null, new ClientSideRouter)


Автозапуск
----------

По умолчанию сервис, объявленный в разделе ``services`` конфига бандла, не будет инициирован до тех пор, пока он не
потребуется в качестве зависимости какому-либо другому сервису или виджету. В некоторых случаях это неудобно.
Например, сервис должен выполнять какую-либо фоновую работу и у него нет внешнего API.

Для автоматического запуска сервиса на этапе инициализации CordJS-приложения, достаточно добавить в его объявление
свойство ``autoStart: true``.

.. _di-inject:

Объявление зависимостей в ``@inject``
=====================================

Внедрение зависимостей происходит сразу после вызова конструктора сервиса с помощью метода ``injectServices``
контейнера сервисов. Метод "смотрит" в статическое свойство ``@inject`` переданного экземпляра сервиса и если
находит, то внедряет прописанные в нём сервисы-зависимости в виде динамических полей экземпляра сервиса.

Свойство ``@inject`` может быть задано в одном из трёх форматов:

* **Массив строк** --- список названий сервисов, которые нужно внедрить. Сервисы будут присвоены одноимённым свойствам
  экземпляра сервиса.
* **Объект**, ключи которого используются как названия полей (алиасы) в сервисе, а значения --- названия сервисов,
  которые нужно внедрить под этими названиями.
* **Функция**, которая (синхронно) возвращает один из двух предыдущих форматов.


API ``ServiceContainer``
========================

Работу по инициализации сервисов и внедрению зависимостей выполняет контейнер сервисов (``ServiceContainer``) ---
специальный сервис, который можно использовать, как и любой другой, по имени ``serviceContainer``. Иногда
приходится пользоваться этим сервисом напрямую, поэтому полезно знать его API.


``injectServices`` --- внедрить зависимости в переданный объект
---------------------------------------------------------------

Метод принимает на вход объект и смотрит в его статическое свойство (свойство конструктора) ``@inject``. Если оно
присутствует, то по принципу, :ref:`описанному выше <di-inject>`, в объект внедряются сервиси-зависимости. Если
какая-либо зависимость не инициирована, то сервис предварительно создаётся. Метод ``injectServices`` возвращает
исходный объект, завёрнутый в :term:`промис`, который резолвится, когда все зависимости внедрены в объект, и
реджектится, если что-то пошло не так. Пример:

.. code-block:: coffee
  :linenos:

  # класс объекта, в который будем внедрять зависимости
  class SomeObject

    @inject: ['someService']

    myMethod: -> # заглушка

  # какой-то сервис, которому нужен этот объект
  class SomeService

    @inject: ['serviceContainer']

    initObject: ->
      @serviceContainer.injectServices(new SomeObject).then (someObject) ->
        console.log 'someObject has someService', someObject.someService

.. note::

  Следует понимать, что пример несколько утрированный, чтобы показать работу метода ``injectServices``, поскольку в
  подобном случае правильнее объявить ``SomeObject`` в конфиге бандла сервисом и добавить его в свойство
  ``SomeService.inject``.


``getService`` --- динамическое получение сервиса
-------------------------------------------------

В некоторых случая использование сервиса-зависимости через ``@inject`` невозможно или неудобно. Например, когда
слишком ранняя его инициализация невозможна. В таком случае можно воспользоваться методом ``getService`` и получить
экземпляр зависимости в тот момент, когда это необходимо и полностью управляемо разработчиком.

``getService`` принимает на вход один аргумент --- строковое название сервиса, и возвращает экземпляр
нужного сервиса зависимости, завёрнутый в :term:`промис`, который резолвится, когда сервис проинициализирован и готов
к использованию (его функция-фабрика в ``config.coffee`` полностью отработала). Пример:

.. code-block:: coffee
  :linenos:

  serviceContainer.getService('currentUser').then (user) ->
    console.log 'current user is', user.login


``get`` --- синхронный доступ к сервису
---------------------------------------

Метод ``get`` так же, как и ``getService``, возвращает сервис по его названию, но делает это синхронно, т.е.
возвращает готовый экземпляр сервиса без заворачивания в промис.

Синхронность накладывает ограничение --- сервис должен быть проинициализирован в момент вызова метода ``get``, если
это не так, то метод бросает исключение. В связи с этим в сочетании с этим методом полезно использовать метод
``isReady``, который принимает на вход название сервиса и возвращет ``true``, если сервис готов и, соответственно,
можно использовать ``get``.

.. warning::

  Несмотря на наличие синхронного API, его использование крайне не рекомендовано. Используя ``getService``, вы
  получите более стабильно-работающий код.


``isDefined`` --- проверка наличия объявления сервиса
-----------------------------------------------------

Если какой-либо сервис использует сервис из другого бандла, но эта зависимость не обязательна (например, другой бандл
может даже не присутствовать в данной конфигурации приложения), то полезна возможность проверить принципиального
наличия сервиса с нужным именем. Для этого можно использовать метод ``isDefined``, который принимает на вход
строковое название сервиса и возвращает ``true``, если сервис объявлен.
